---
layout: article
title: "重要知识点（不完全）"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: 4002502.jpg
  thumb:
date: 2016-03-08T22:00:29+08:00
---


① java的内存模型？

② 垃圾回收机制

③ 并发，锁

④ object类中有什么方法？（之前还看过一次，结果临场只说了6个，漏了finalize()、getClass()，居然漏了toString()。。。）

⑥ 常用排序的优缺点和适用情况

项目的问题

kmp算法

SQL语句

JVM结构 

找出一个大文本大的top3字符串

淘宝用户的数据（购物车放在哪里），怎么满足高并发

输入两个数组，返回一个数组：两个数组中的公共值

写一个函数，输入int型，返回整数逆序后的字符串。如：输入123，返回“321”。 要求必须用递归，不能用全局变量，输入必须是一个参数，必须返回字符串。”

项目经历

很多人进入HR面试还是有很大可能被淘汰

struct2是怎么实现的，原理是什么

session是怎么实现的

java怎么创建链表的

ArrayList和LinkedList有什么区别

int类型的数据是32位的，怎么知道一个32位的二进制数据有多少个1

互斥、信号量、进程、线程

hash函数相关的

一个数组存有很多个字母，怎么知道26个字母中的那个没有存储

IOC是什么，内部是怎么实现的，写一下伪代码

AOP呢？

代理模式知道吗，利用JDK自带的类写一个代理模式

银行排队算法是什么

Ehcache源码

说说红黑树的特点和性能

说说JDK中类的源码

写个单列模式

并发的方法知道哪些

比较一些阿里、微软中国、腾讯等公司，技术方面的差异

堆栈的区别

问你所用过的框架中，你比较喜欢那个，为什么

哪个项目中的收获最大，收获到什么

servlets的生命周期

spring的两个主要特性（AOP和IOC）

说说你所理解的J2EE是什么

Hibernate的优点和缺点

你所知道的MVC框架还有哪些

大量数据访问如何实现并发和同步

答：采用乐观锁的方式，大数据如果访问十分频繁乐观锁不断失败可能导致线程饥饿的情况 还可以用读写锁和分段锁

window上的程序如何转移到linux上，需要做哪些改动，你怎么看待linux？

答：重新编译程序 对系统调用方面的函数做相应的修改，linux是个非常棒的系统 稳定 开源 免费 （个别商业版除外）

window32位和window64的区别。

答：最基本的区别是32位的指针大小是4byte 64位为8byte内存寻址范围也不同

数据库的死锁如何解除

structs2是怎么实现的

sql优化 

如何优化JVM

各种mysql数据库引擎的却别

threadlocal，

一致性hash算法原理

写程序实现“2000W用户根据年龄排序”的问题

剑指名企offer

String为什么要设计成为final对象

comparable和comparator的区别

IO/NIO的区别

常见并发包下的类实现

线程池各参数的调整

JVM内存模型

AOP（多种动态代理实现）

缓存（各缓存的区别，实现原理）

消息（JMS机制，主从部署备份实现等），

zookeeper选举算法，

dubbo框架，

各种序列化框架，

一致性hash，

倒排索引原理实现等。

面的问题都是我简历里面写的，特别是写的熟练掌握，深入理解的点全部会重点问，直到最底层的实现

java内存模型

各种垃圾回收算法

分布式事务

类加载器

volatile和syschonized的底层实现原理

答：最基本的区别是32位的指针大小是4byte

简述快速排序 

传递参数时，什么时候是值传递，什么时候是引用传递 

Jdk1.8新特性,

Spring的原理，事务如何管理，如何防止脏读数据, 

说说方法sysnchrnized 和方法块sysnchrnized区别, 

Hibernate的延迟加载，session何时开启，何时关闭. 

对java应用的内存处理机制，线程工作原理，并有没有在项目中实际解决该类问题的经验； 

有没有在项目中有过系统性能调优，性能跟踪，内存泄漏定位等相关经验，
 
在解决实际问题时，是否有了解解决问题方法的本质（解决方案的系统原理）；
 
对关系型数据库工作原理，以及关键性能影响点的了解及项目中的实际经验； 

string，stringbuffer 和stringbuilder的区别 

struts1和2的区别 

ArrayList,HashMap,HashTable区别 

谈谈NIO 

OBJECT有些什么函数，都是做什么用的 

JSP,SERVLE是线程安全的吗？为什么？ 

说出Servlet的生命周期，并说出Servlet和CGI的区别

答：Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。

说出ArrayList,Vector, LinkedList的存储性能和特性 

答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 

HashMap和Hashtable的区别

答：HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 

sleep() 和 wait() 有什么区别? 

答：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

同步和异步有何异同，在什么情况下分别使用他们？举例说明。 

答：如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 

abstract class和interface有什么区别? 

答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 
　接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。 

forward 和redirect的区别 

答：　forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 
    redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。 
	
GC是什么? 为什么要有GC? 

答：GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 
  
编程题: 写一个Singleton出来。 

答：
　Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 
一般Singleton模式通常有几种种形式: 
　第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。 

public class Singleton { 
private Singleton(){} 
　　    //在自己内部定义自己一个实例，是不是很奇怪？ 
　　    //注意这是private 只供内部调用 
　　    private static Singleton instance = new Singleton(); 
　　    //这里提供了一个供外部访问本class的静态方法，可以直接访问　　 
　　    public static Singleton getInstance() { 
　　　　    return instance; 　　 
　　    } 
    }  


    第二种形式: 

public class Singleton { 
　　private static Singleton instance = null; 
　　public static synchronized Singleton getInstance() { 
　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　 　 
　　//使用时生成实例，提高了效率！ 
　　if (instance==null) 
　　　　instance＝new Singleton(); 
return instance; 　　} 
} 


其他形式: 
定义一个类，它的构造函数为private的，所有方法为static的。 
一般认为第一种形式要更加安全些 

请说出你所知道的线程同步的方法。

答：
wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 
Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 

多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 

答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 
同步的实现方面有两种，分别是synchronized,wait与notify 

答：线程的基本概念、线程的基本状态以及状态之间的关系 
　线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。
Java中的线程有四种状态分别是：运行、就绪、挂起、结束。

java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
 
答：有两种实现方法，分别是继承Thread类与实现Runnable接口 
用synchronized关键字修饰同步方法 
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。

启动一个线程是用run()还是start()? 

答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 
run()方法:在本线程内调用该Runnable对象的run()方法，可以重复多次调用；
start()方法:启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程；

HashCode的作用是什么？ 

答：HashCode就是一个散列码，用来在散列存储结构中确定对象的存储地址。HashMap，HashSet，他们在将对象存储时，需要确定它们的地址，而HashCode就是做这个用的。在默认情况下，由Object类定义的hashCode方法会针对不同的对象返回不同的整数，这一般是通过将该对象的内部地址转换成一个整数来实现的。 

Hash算法？ 

答：HashCode是用来查找用的，它可以提高查找效率。举例说： 
内存中有0，1，2，3，4，5，6，7…，N一共N+1个位置可以存储对象，然后类中有个字段叫ID，如何确定这个对象在内存中的存储位置呢？用ID%(N+1)得到的余数就是存储的位置，当要查找这个对象的时候，只需要将ID%(N+1)的余数得到，就可以立即找到这个对象，大大提高了查找效率。 

为什么实现了equals()方法后必须重写hashCode()方法？ 

答：由于java.lang.Object的规范，如果两个对象根据equals()方法是相等的，那么这两个对象中的每一个对象调用hashCode方法都必须生成相同的整数结果。举例说，在HashSet中，通过被存入对象的hashCode()来确定对象在HashSet中的存储地址，通过equals()来确定存入的对象是否重复，hashCode()和equals()都需要重新定义，因为hashCode()默认是由对象在内存中的存储地址计算返回一个整数得到，而equals()默认是比较对象的引用，如果不同时重写他们的话，那么同一个类产生的两个完全相同的对象就都可以存入Set，因为他们是通过equals()来确定的，这就是HashSet失去了意义。 
Map的思想是查找对象要比线性查找更快，使用hashed keys 来定位需要查找的对象需要两步。Map的内部存贮以二维数组的形式类似的方式存储对象，第一个数组的索引是key的hashcode()之后的值。对第二个层数组的查找是利用equals()进行线性比较来确定对象是否存在。
对象中默认实现的hashcode()对不同的对象返回不同的整数。因此，在上边的例子中，不同的对象（即使是相同的类型）都有不同的hashCode()。
如果，只是重写了equal可能在查找的时候，找不大存储的对象
Maven的工作原理？ 

答：采用远程仓库和本地仓库以及一个类似build.xml的pom.xml，将pom.xml中定义的jar文件从远程仓库下载到本地仓库，哥哥应用使用同一个本地仓库的jar，同一个版本的jar只需要下载一次，而且避免每个应用都去拷贝jar。同时它采用了插件的体系架构，只保留最小号核心，其余功能都通过插件的形式提供。 

iBatis和Hibernate的区别和各自优缺点？
 
答：IBATIS的最大优点是控制SQL发送的数目，提高数据层的访问效率。IBATIS是半自动化的，通过表和对象的映射以及手写的SQL语句，可以实现比Hibernate更高的查询效率。它的优点具体有易于学习和掌握，容易对SQL进行优化，可以进行细粒度的优化。缺点就是不同的数据库支持不好，缺省的cache支持不好。 

Hibernate对JDBC进行了轻量级的封装，使得Java程序员可以使用对象编程的思维来操作数据库。优点是它使用Java反射机制而不是字节码增强程序来实现透明性，它的性能比较好，因为它是个轻量级的框架，映射灵活出色，支持多种关系型数据库，从一对一到多对多的各种复杂关系。缺点是限制你所使用的对象模型，比如一个持久性类不能映射到多个表。 

JDBC

HashMap和HashTable的区别？ 

答：Hashtable是基于陈旧的Dictionary类的，HashMap是Java1.2中引进的Map接口的一个实现。Hashtable是线程安全的，HashMap不是线程安全的。HashMap可以将null作为一个条目的key或者value。 

List，Set和Map的区别？ 

答：List顺序存储，可以存储相同的对象。Set顺序存储不能存储相同的对象。Map中含有将key,value作为一组值作为一条记录来存储，key和value都可以分别作为一个collection取出来。 

谈谈Java的反射机制？
 
答：Java发射机制可以让我们在运行时加载，探知，使用编译期间完全未知的classes。换句话说就是Java程序可以加载一个在运行时才得知名称的class，获悉其完整构造，并生成其对象实体，或对其fields设值，或调用其methods。 

谈谈JVM工作原理？ 

答：操作系统装入jvm是通过jdk中的java.exe来完成的，通常有下面四个步骤。1.创建jvm装载环境和配置。2.装载jvm.dll。3.初始化jvm.dll并挂接到JNIENV(JNI调用接口)实例。4.调用JNIENV实例装载并处理class类。 

谈谈ClassLoader的工作原理？ 

答：ClassLoader是用来Class文件到JVM的。ClassLoader在JVM运行的时候加载java核心API以满足java程序最基本的需要，其中就包括用户定义的ClassLoader，这里所谓的用户定义是只通过java程序实现的ClassLoader，一个是ExtClassLoader，这个ClassLoader是用来加载java的扩展API的，也就是/lib/ext中的类。一个是AppClassLoader，这个ClassLoader是用来加载用户机器上CLASSPATH设置目录中的Class的，通常在没有指定ClassLoader的情况下，程序员自定义的类就由该ClassLoader来进行加载。 
当运行一个程序的时候，JVM启动，运行bootstrap classloader，该ClassLoader加载Java核心API(ExtClassLoader和AppClassLoader也在此时加载)，然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class。这就是一个程序最基本的加载流程。 

Google是怎么做到一提交Query就立马返回结果？ 

答：因为它使用了倒排索引的技术。

说几个J2EE中使用的协议？ 

答：SOAP, JAXP, JAXM, UDDI 

如何在Oracle中实现分页查询？
 
答：select * from (select rownum as rowno, T.* from k_task T where … and rownum <= 20) table_alias where table_alias.rowno >= 10; 如果要排序的话把排序子句放到内层查询。 

Web Application是通过什么来启动Servlet的？ 

答：Servlet由Web服务器加载启动。 

举例几个Apache上的开源项目？ 

答：iBatis，Maven，Velocity，POI，Ant, Apache HTTP Server. 

Object类有哪些方法？ 

答：equals(), hashCode(), getClass(), toString(), notify(), notifyAll(), wait(), clone() 

equals()和==的区别？

基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean 他们之间的比较，应用双等号（==）,比较的是他们的值。 
复合数据类型(类) 当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 

JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。

Servlet的生命周期： 
    
servlet有良好的生存期的定义，包括如何加载、实例化、初始化、处理客户端请求以及如何被移除。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。 

1、加载和实例化 

　　容器负责加载和实例化一个servlet。实例化和加载可以发生在引擎启动的时候，也可以推迟到容器需要该servlet为客户请求服务的时候。 

　　首先容器必须先定位servlet类，在必要的情况下，容器使用通常的Java类加载工具加载该servlet，可能是从本机文件系统，也可以是从远程文件系统甚至其它的网络服务。容器加载servlet类以后，它会实例化该类的一个实例。需要注意的是可能会实例化多个实例，例如一个servlet类因为有不同的初始参数而有多个定义，或者servlet实现SingleThreadModel而导致容器为之生成一个实例池。 

　　2、初始化 

　　servlet加载并实例化后，容器必须在它能够处理客户端请求前初始化它。初始化的过程主要是读取永久的配置信息，昂贵资源（例如JDBC连接）以及其它仅仅需要执行一次的任务。通过调用它的init方法并给它传递唯一的一个（每个servlet定义一个）ServletConfig对象完成这个过程。给它传递的这个配置对象允许servlet访问容器的配置信息中的名称－值对（name-value）初始化参数。这个配置对象同时给servlet 提供了访问实现了ServletContext接口的具体对象的方法，该对象描述了servlet的运行环境。 

　　2.1初始化的错误处理 

　　在初始化期间，servlet实例可能通过抛出UnavailableException 或者 ServletException异常表明它不能进行有效服务。如果一个servlet抛出一个这样的异常，它将不会被置入有效服务并且应该被容器立即释放。在此情况下destroy方法不会被调用因为初始化没有成功完成。在失败的实例被释放后，容器可能在任何时候实例化一个新的实例，对这个规则的唯一例外是如果失败的servlet抛出的异常是UnavailableException并且该异常指出了最小的无效时间，那么容器就会至少等待该时间指明的时限才会重新试图创建一个新的实例。 

　　2.2、工具因素 

　　当工具（注：根据笔者的理解，这个工具可能是应用服务器的某些检查工具，通常是验证应用的合法性和完整性）加载和内省（introspect）一个web应用时，它可能加载和内省该应用中的类，这个行为将触发那些类的静态初始方法被执行，因此，开发者不能假定只要当servlet的init方法被调用后它才处于活动容器运行状态（active container runtime）。作为一个例子，这意味着servlet不能在它的静态（类）初始化方法被调用时试图建立数据库连接或者连接EJB容器。 

　　3、处理请求 

　　在servlet被适当地初始化后，容器就可以使用它去处理请求了。每一个请求由ServletRequest类型的对象代表，而servlet使用 ServletResponse回应该请求。这些对象被作为service方法的参数传递给servlet。在HTTP请求的情况下，容器必须提供代表请求和回应的HttpServletRequest和HttpServletResponse的具体实现。需要注意的是容器可能会创建一个servlet实例并将之放入等待服务的状态，但是这个实例在它的生存期中可能根本没有处理过任何请求。 

　　3.1、多线程问题 

　　容器可能同时将多个客户端的请求发送给一个实例的service方法，这也就意味着开发者必须确保编写的servlet可以处理并发问题。如果开发者想防止这种缺省的行为，那么他可以让他编写的servlet实现SingleThreadModel。实现这个类可以保证一次只会有一个线程在执行service 方法并且一次性执行完。容器可以通过将请求排队或者维护一个servlet实例池满足这一点。如果servlet是分布式应用的一部分，那么，那么容器可能在该应用分布的每个JVM中都维护一个实例池。如果开发者使用synchronized关键字定义service方法(或者是doGet和 doPost)，容器将排队处理请求，这是由底层的java运行时系统要求的。我们强烈推荐开发者不要同步service方法或者HTTPServlet 的诸如doGet和doPost这样的服务方法。 

　　3.2、处理请求中的异常 

　　servlet在对请求进行服务的时候有可能抛出ServletException或者UnavailableException异常。ServletException表明在处理请求的过程中发生了错误容器应该使用合适的方法清除该请求。UnavailableException表明servlet不能对请求进行处理，可能是暂时的，也可能是永久的。如果UnavailableException指明是永久性的，那么容器必须将servlet从服务中移除，调用它的destroy方法并释放它的实例。如果指明是暂时的，那么容器可以选择在异常信息里面指明的这个暂时无法服务的时间段里面不向它发送任何请求。在这个时间段里面被被拒绝的请求必须使用SERVICE_UNAVAILABLE (503)返回状态进行响应并且应该携带稍后重试（Retry-After）的响应头表明不能服务只是暂时的。容器也可以选择不对暂时性和永久性的不可用进行区分而全部当作永久性的并移除抛出异常的servlet。 

　　3.3线程安全 

　　开发者应该注意容器实现的请求和响应对象（注：即容器实现的HttpServletRequest和HttpServletResponese）没有被保证是线程安全的，这就意味着他们只能在请求处理线程的范围内被使用，这些对象不能被其它执行线程所引用，因为引用的行为是不确定的。 

　　4、服务结束 

　　容器没有被要求将一个加载的servlet保存多长时间，因此一个servlet实例可能只在容器中存活了几毫秒，当然也可能是其它更长的任意时间（但是肯定会短于容器的生存期）当容器决定将之移除时（原因可能是保存内存资源或者自己被关闭），那么它必须允许servlet释放它正在使用的任何资源并保存任何永久状态（这个过程通过调用destroy方法达到）。容器在能够调用destroy方法前，它必须允许那些正在service方法中执行的线程执行完或者在服务器定义的一段时间内执行（这个时间段在容器调用destroy之前）。一旦destroy方法被调用，容器就不会再向该实例发送任何请求。如果容器需要再使用该servlet，它必须创建新的实例。destroy方法完成后，容器必须释放servlet实例以便它能够被垃圾回收。 


Java中Error与Exception的区别： 

Exceptions 

1．可以是 可被控制(checked) 或 不可控制的(unchecked) 

2．表示一个由程序员导致的错误 

3．应该在应用程序级被处理 

Errors 

1．总是 不可控制的(unchecked) 

2．经常用来用于表示系统错误或低层资源的错误 

3．如何可能的话，应该在系统级被捕捉 

error   表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。  

Java的序列化接口的作用： 

Serializable接口，是作为一个标记使用的，因为本身没有任何方法需要实现； 
Java内部的序列化机制会检查此接口，如果有这个接口，则序列化它，否则不序列化。 
典型的用途是在分布式Java编程里，比如通过RMI或者EJB，需要在网络上传输的对象，一定要实现此接口，否则程序会出错，因为在网络上传递对象需要先序列化它。 

使用序列化的目的有一个两个:一个是为了persistent对象,如在Hibernate中要保存的对象必须是序列化的;第二个是为了跨平台传输,消除平台间的差异,如在JMS中,传送的消息对象都必须是序列化的. 

Hibernate的三种状态以及表现形式： 



objects在hibernate中的生命周期中存在3种状态:transient, persistent, detached。附件1描述的即是hibernate application中objects的生命周期。 

通过new操作符生成的object是transient object，此时的object还没有和数据库中的任何数据关联，所以一旦没有被引用，就会被jvm垃圾收集。一旦通过Hibernate 的Persistence manager执行了save()方法或者被其他已经存在的Persistent objects引用，那么object的状态就会从transient转为persistent。 

Persistent objects是包含在transactions中的，它们的状态是通过transactions来控制的，  Persistent objects是和数据库中的表对应的，所以表示主键的属性不会为空，也就是说每一个persistent object都会有一个匹配的database identity，除非是通过new产生的新的transient object,此时object的database identity是空的，如果在transaction中对该object执行save()方法，那么在transaction成功结束的时候该 object会在数据库中新增一条对应的记录，其它已经存在的persistent objects会相应的更新数据库中的相应行。 

当Hibernate中的Persistence Manager执行close()方法，也就是persistence Manager放弃对persistent objects的控制，那么persistent objects的状态就转为detached objects。这些detached objects可以在未来被新的persistence manager重新控制并使用。这种将object从transaction转向表现层然后又重新包含于新的Transaction的实现是 Hibernate的一个卖点。 

在objects存在的三种状态中，处于persistent状态中object的比较是通过该object的database identity来确定的，所以这里需要override equals()来实现。其它状态中的objects就可以简单的通过java的equality来判断即可。

java web 必然会牵涉到servlet

java多线程 原理性和底层机制

算法题，字符串相互转化

spring in action 

structs in action

Hibernate的电子书

深入分析java web

http协议302/301是什么意思

程序员的自我修养

## 底层

JVM的结构和工作原理

java的内存模型

各种GC算法

Classloader的加载原理

程序编译链接过程以及二进制文件的处理

JVM监控及调优

JVM多线程

I/O，java中常提到的是BIO/NIO，即阻塞形IO和非阻塞型IO，结合linux中的同步I/O和非同步I/O

## servlet

Servlet是运行于服务端的java程序，一般实现自己的Java服务端应用都从HttpServlet类继承，然后实现自己的init | doGet | doPost | service方法。Servlet的生命周期从其加载开始，首先执行一次初始化，调用init方法，之后便可运行自身的服务，当生命周期结束时，调用destroy方法回收资源，结束服务。

仅了解原理当然是不够的，还要实战能力，在IDE中写写简单的代码谁都会，然而真正让一个程序能够运行起来也还需要点其他的东西，这里我指的是Servlet的容器。servlet的容器有很多，常用的以Tomcat为例，安装好Tomcat后，在开发时必须包含进Tomcat的lib。IDE确实惯坏了好多人，目录如何组织，程序如何编译、如何部署这些问题都被IDE屏蔽掉了，如果要对整体有比较透彻的了解，建议一切从命令行动手。

servlet与JSP核心编程

## spring

原文地址：http://www.w2bc.com/Article/84529

## Hibernate

原文地址：http://www.w2bc.com/Article/84529

## HTTP

http的报头格式

Http协议的各种返回码是什么意思

https如何实现

B/S架构的工作原理

Cookie和Session的原理

restful API

## 其他问题

首先自我介绍

session了解不，怎么实现？这个应该是ActionContext对象实现。

链表，怎么创建链表

protected访问权限，排一下其他访问权限关键字的顺序

用过哪些list

HashMap怎么实现的，先是数组，然后是链表存储，每个方法怎么实现的，最好自己实现一边，要么看看源码

set、treeset、HashSet等

nio，可以读取大数据

int类型的数据时32位的，怎么知道一个32位的二进制数据有多少个1

## 操作系统的知识要准备：互斥、信号量等等

## 计算机网络，三次握手、原理、流程

http协议

在输入一个地址之后做什么操作，域名解析

服务器做什么

快排 归并

## oracle和mysql深层的东西

hash 函数

hashcode

一个数组存储很多英文字母，问：怎么知道26个字母中哪些没有存储？（好几个方案）

## 切不可瞎编

http请求头

static关键字

struct结构体

IP池底层原理

堆排序

tcp状态图各种细节

b树和b+树的区别

mysql用的b树还是b+树，为什么？优点

数据库ACID

mongodb底层原理

tcp三次握手的过程，accept发生在三次握手哪个阶段？

b+树和hash的应用场景

key为4字节到128字节的100万条数据k-v的，怎么查询（hash）

守护进程的特点

算法（主要是排序）

概率（条件概率）

操作系统（线程、进程、进程间通信）

计算机网络（TCP握手、某协议属于哪一层）

Linux命令、数据库


## Struts,Spring,Hibernate三大框架的笔试题

原理： 
a.读取并解析配置文件 
b.读取并解析映射信息，创建SessionFactory 
c.打开Sesssion 
d.创建事务Transation 
e.持久化操作 
f.提交事务
g.关闭Session 
h.关闭SesstionFactory 

为什么要用：
a. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。
b. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作
c. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 
d. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 

2．Hibernate是如何延迟加载?
a. Hibernate2延迟加载实现：a)实体对象 b)集合（Collection）
b. Hibernate3 提供了属性的延迟加载功能 当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。
c．Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系) 类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many 
d.Struts1流程：
（1）客户端浏览器发出HTTP请求。
（2）根据web.xml配置，该请求被ActionServlet接收。
（3）根据struts-config.xml配置， ActionServlet先将请求中的参数填充到ActionForm中，然后ActionServlet再将请求发送到Action 进行处理。
（4）是否验证，需要验证则调用ActionForm的validate方法，验证失败则跳转到input，成功则继续。
（5）Action从ActionForm获得数据，调用javabean 中的业务方法处理数据。
（6）Action返回ActionForward对象，跳转到相应JSP页面或Action。
（7）返回HTTP响应到客户端浏览器。MVC设计模式：modal：“模型” 也称业务逻辑，是正真完成任务的代码,相当与JavaBeanview：视图，其实就是显示界面，相当于JSPcontroller：控制器，他控制模型和视图的交互过程，相当于servletstruts1是基于MVC设计模式hibernate是基于ORM对象关系映射

5.struts是什么？
struts1是基于JSP和servlet的一个开源的Web应用框架，使用的是MVC的设计模式struts2是基于webwork技术的框架，是sun和webwork公司联手开发的一个功能非常齐全的框架，struts2和struts1没有任何关系，是一个全新的框架 

6.spring是什么？
spring是一个集成了许多第三方框架的大杂烩，其核心技术是IOC（控制反转，也称依赖注入）和AOP（面向切面编程） 

7.hibernate是什么？
hibernate是基于ORM对象关系映射（完成对象数据到关系数据映射的机制）实现的,做数据持久化的工具 

8.JSF是什么？
JavaServer Face是基于组件的web开发框架，跟sturts差不多的框架 

9.数据库里面的索引和约束是什么?
索引是为了提高数据的检索速度，索引是建立在数据表上，根据一个或多个字段建立的约束是为了保持数据的完整性，约束有非空约束，主键约束，外键约束等等。

10.spring是什么这个问题，往往可以通过我们为什么要使用spring这个问题来切入：
AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用AOP 后，公共服务 （比 如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词 倒置 所表明的，IOC就像反 过来的 JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straight construction），每一个对象都是用其协作对象构造的。因此是由容器管理协作对象（collaborator）。 Spring即使一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了 Spring，只要用 JavaBean 属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象。 

11.用自己的话简要阐述struts2的执行流程。
Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。核心控制器FilterDispatcher是Struts2框架的基础，包含了框架内部的控制流程和处理机制。业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。 Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts 2是WebWork的升级版本。

基本简要流程如下：
a、客户端浏览器发出HTTP请求。
b、根据web.xml配置，该请求被FilterDispatcher接收。
c、根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。
d、Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。
e、Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。
f、返回HTTP响应到客户端浏览器。

数据库第三范式

乐观锁

concurrent包源码：HashMap、hashtable、concurrentHashMap的区别

spring的applicationcontext和beanfactory的区别

servlet安全机制

JVM

## 我对这个公司产品短期、中期和长期影响

做好提前两个月准备，持久战

编程之美

## 不要纠结在最佳思路，10-15钟内给出方案，并分析复杂度

1、大数据量的 urllog，怎么去重且统计每个 url 的出现次数，复杂度分析；

2、设计 cache 系统

●设计 cache 的接口；

●可以用什么数据结构实现；

●如何实现可伸缩的容量；

●cache 的空间管理策略，比如 cache 哪些条目，何时清理；

●cache 系统启动时分配多大的空间，之后按照怎样的策略增大；

1.一个只有一个数字的字符串。用尽可能多的方法将其转化成对于的数字。
     
2.写一个vector。实现resize\opertor[]\clear。
     
3.快速生成4亿个随机数。 

## 阿里实习内推

1.java中所有类的父类是什么？他都有什么方法？
2.java中IO包下面的inputstream运用了什么设计模式？请简述你知道的设计模式?
3.ArrayList跟LinkedList的区别详细说出？
4.session和cookie的区别？
5.说一下快速排序的原理？
6.如何在hibernate中查看原始的sql语句？
7.简述AOP，及其作用？
8.struts2的流程？
9.简述下多线程？
10.Linux？（问到了不会就没问）
11.项目中的一些问题
12.java有些类中为什么需要实现Serializable接口？
13.hashmap，hashtable的区别？以及如何使用，以及他的一些方法？
14.设计题，利用hashmap对苹果的重量进行排序？
15.struts2拦截器相关问题？
16.struts2接受参数的方式？
17.数据结构要会（本人很渣）
18.异常的相关问题？error和exception具体？
19.还问了个MYSQL如何查看运行状态没听懂不过肯定不会就pass了？
20.问了一些关于collections的方法？
21.servlet相关知识，doPost，doGet，一些内置对象？
23.set和list的区别，一些个实现类，继承关系等等？
24.在Hibernate中java的对象状态有哪些？
25.简述你看过java类的源代码？
26.数据库事务隔离机制及其特点是什么？
27.JVM内存heap and stack
28.HTTP报文包含内容？
29.TCP/IP三次握手？
30.垃圾回收？
31.其他问了未来规划，在学校学的最好的一门，然后教育了下我说大公司注重基础跟潜力，小公司注重上来就会做事，要多看源码多看jdk注重java基础！！！

一个月的时间大概5天面一次一共面了5轮下面是三面，四面的问题分享给大家
1.什么是 java 序列化， 如何实现 java 序列化？或者请解释 Serializable 接口 接口的作用？
2.MVC的各个部分都有那些技术来实现? 如何实现?
3.开发中主要使用 Spring 的什么技术 ?
4.对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理？
5.hashmap底层如何实现的？
6.arrayList底层如何扩展的？
7.谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的？
8.谈谈你在项目中的角色？
9.你做过的项目模块实现？
10.线程同步，并发操作怎么控制？
11.servlet容器启动过程，生命周期？
12.SQL关联关系？
13.list去重？
14.arraylist和hashmap在内存中开销？
15.sql行转列？



HR面问题
1.你同学如何评价你？
2.我们阿里为什么要招你进来？
3.你们老师如何评价你做的项目？
4.你的优缺点？
5.未来的规划？
6.什么时间能入职？有没有投过其他公司？
7.你的成绩在前30%并不是很好，简述你的特长？


1.从浏览器输入一个url到返回数据中间发生了什么。
 我从网络和服务器的具体操作方面详细的回答了。因为这个问题做不同方向的人回答的重点不一样。面试官也提醒我说要详细说一下服务器方面的操作。我详细说了处理数据方面（数据库或cache）

     2. 然后面试官就根据我的回答，给我出了一个设计题。当需要我设计一个API，根据某个参数返回对应的数据。中间既有访问文件，既有访问内存的。具体应该是考察代码解耦方面的。我就说了可以采用多态或者依赖注入的方式。
    3.  详细介绍了DI的方式和具体自己的实现和作用。
    4.  对MVC的看法。同时让我介绍我使用的框架的优雅和不足之处。然后我就开始说现在公司一般用RPC框架。原因好处等等。
一面持续了20多分钟吧。就问了代码设计方面的比较多。回答也不是很好。。
然后一直在等二面。等了足足7天。。

项目中的设计模式

事务   银行转账例子。。   a和b不在同一个库里面的事务设计。mysql怎么做。自己写代码怎么实现

db方面，如果上线了的db查询变慢了。怎么定位，解决方法
         定位的话，说了mysql的监控，包括日志什么的。解决的方法说了分布式，加cache。然后问了一台mysql挂了，如何做，立刻切换到备份机，备份机的机制使用复制，复制是怎么完成的。

4.设计题。40亿qq号，20w/s QPS ，设置怎么存储，怎么解决请求。单机是32G内存，1T硬盘，抗5w/s极限请求。
        特别想知道是怎么设置存储，减低存储量和怎么查找快（半个小时，在纸上画，还算这样设置占了多少内存，多少硬盘，数据结构是怎样的。。）
        从设置索引到分析qq号的特性来完成存储什么。面试官也会提示，一问一答让这个系统怎么设置的更好。反正没有最好答案。
   5.手写了个字符串逆序


1、Tomcat的优化经验
答:去掉对web.xml的监视，把jsp提前编辑成Servlet。
有富余物理内存的情况，加大tomcat使用的jvm的内存

2、HTTP请求的GET与POST方式的区别
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。

3、解释一下什么是servlet;
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。

4、说一说Servlet的生命周期?
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。
web容器加载servlet，生命周期开始。通过调用servlet的init()方法进行servlet的初始化。通过调用service()方法实现，根据请求的不同调用不同的do***()方法。结束服务，web容器调用servlet的destroy()方法。

5、Servlet的基本架构
publicclass ServletName extends HttpServlet {
public void doPost(HttpServletRequest request,HttpServletResponse response)throws
ServletException, IOException {
}
public void doGet(HttpServletRequest request,HttpServletResponse response)throws
ServletException, IOException {
}
}

6、SERVLET API中forward()与redirect()的区别？
答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用
sendRedirect()方法。

7、什么情况下调用doGet()和doPost()？
Jsp页面中的FORM标签里的method属性为get时调用doGet()，为post时调用doPost()。

8、Request对象的主要方法：
setAttribute(String name,Object)：设置名字为name的request的参数值
getAttribute(String name)：返回由name指定的属性值
getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例
getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组
getCharacterEncoding()：返回请求中的字符编码方式
getContentLength()：返回请求的Body的长度
getHeader(String name)：获得HTTP协议定义的文件头信息
getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例
getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例
getInputStream()：返回请求的输入流，用于获得请求中的数据
getMethod()：获得客户端向服务器端传送数据的方法
getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值
getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例
getParametervalues(String name)：获得有name指定的参数的所有值
getProtocol()：获取客户端向服务器端传送数据所依据的协议名称
getQueryString()：获得查询字符串
getRequestURI()：获取发出请求字符串的客户端地址
getRemoteAddr()：获取客户端的IP地址
getRemoteHost()：获取客户端的名字
getSession([Boolean create])：返回和请求相关Session
getServerName()：获取服务器的名字
getServletPath()：获取客户端所请求的脚本文件的路径
getServerPort()：获取服务器的端口号
removeAttribute(String name)：删除请求中的一个属性

9、forward和redirect的区别
forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。
   redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。

10、request.getAttribute()和request.getParameter()有何区别?

11. jsp有哪些内置对象?作用分别是什么?分别有什么方法？
答:JSP共有以下9个内置的对象：
request 用户端请求，此请求会包含来自GET/POST请求的参数
response 网页传回用户端的回应
pageContext 网页的属性是在这里管理
session 与请求有关的会话期
application servlet 正在执行的内容
out 用来传送回应的输出
config  servlet的构架部件
page JSP网页本身
exception 针对错误网页，未捕捉的例外

request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header,和session数据的有用的方法。
   response表示HttpServletResponse对象，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）
   out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。
   pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。
   session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息
   applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息
   config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。
   page表示从该页面产生的一个servlet实例

12. jsp有哪些动作?作用分别是什么?
（这个问题似乎不重要，不明白为何有此题）
答:JSP共有以下6种基本动作
jsp:include：在页面被请求的时候引入一个文件。
jsp:useBean：寻找或者实例化一个JavaBean。
jsp:setProperty：设置JavaBean的属性。
jsp:getProperty：输出某个JavaBean的属性。
jsp:forward：把请求转到一个新的页面。
jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记

13、JSP的常用指令
isErrorPage(是否能使用Exception对象)，isELIgnored(是否忽略表达式)

14. JSP中动态INCLUDE与静态INCLUDE的区别？
答：动态INCLUDE用jsp:include动作实现
<jsp:include page=included.jsp flush=true />它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面 <%@include file=included.htm %>

15、两种跳转方式分别是什么?有什么区别?
（下面的回答严重错误，应该是想问forward和sendRedirect的区别，毕竟出题的人不是专业搞文字艺术的人，可能表达能力并不见得很强，用词不一定精准，加之其自身的技术面也可能存在一些问题，不一定真正将他的意思表达清楚了，严格意思上来讲，一些题目可能根本就无人能答，所以，答题时要掌握主动，只要把自己知道的表达清楚就够了，而不要去推敲原始题目的具体含义是什么，不要一味想着是在答题）
答：有两种，分别为：
<jsp:include page=included.jsp flush=true>
<jsp:forward page= nextpage.jsp/>
前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。

16、页面间对象传递的方法
request，session，application，cookie等

17、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？
JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是"类servlet"。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。

18、MVC的各个部分都有那些技术来实现?如何实现?
答:MVC是Model－View－Controller的简写。Model代表的是应用的业务逻辑（通过JavaBean，EJB组件实现），View是应用的表示面（由JSP页面产生），Controller是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。

19、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？
PublicString translate(String str) {
   String tempStr ="";
   try {
     tempStr =newString(str.getBytes("ISO-8859-1"), "GBK");
     tempStr =tempStr.trim();
   }
   catch (Exception e) {
    System.err.println(e.getMessage());
   }
   return tempStr;
}


算法题：给你1000亿的数，无序，找出它的中值。（主要考虑内存不足、尽量减少IO次数）这个题自己说了两种思路：哈希；用数的最高位的0或1对文件进行划分类似剑指offer第40题的方法，最后他提示了一种用位图的思路。这个题互相讨论了很久。


## 剑指offer 

3 如果在浏览器的URL输入栏输入 tao,如何给用户自动提示相关的URL地址，比如www.taobao.com

4 平时除了做项目，还喜欢做什么？扯自己多么上进，看了Nginx。

5 最大优点、最大缺点？

问题一：MySQL中索引有哪些类型？

解析：
索引类型: B-TREE索引，哈希索引B-TREE索引加速了数据访问，因为存储引擎不会扫描整个表得到需要的数据。相反，它从根节点开始。根节点保存了指向子节点的指针，并且存储引擎会根据指针寻找数据。它通过查找节点页中的值找到正确的指针，节点页包含子节点的指针，并且存储引擎会根据指针寻找数据。它通过查找节点页中的值找到正确的指针，节点页包含子节点中值的上界和下界。最后，存储引擎可能无法找到需要的数据，也可能成功地找到包含数据的叶子页面。
 
B-TREE索引 对于以下类型查询有用。匹配全名、匹配最左前缀、匹配列前缀、匹配范围值、精确匹配一部分并且匹配某个范围中的另一部分；
 
B-TREE索引的局限：如果查找没有从索引列的最左边开始，它就没什么用处。不能跳过索引中的列，存储引擎不能优先访问任何在第一个范围条件右边的列。例：如果查询是where last_name=’Smith’ AND first_name LIKE ‘J%’ ANDdob=’1976-12-23’;访问就只能使用索引的头两列，因为LIKE是范围条件。
 
哈希索引建立在哈希表的基础上，它只对使用了索引中的每一列的精确查找有用。对于每一行，存储引擎计算出了被索引列的哈希码，它是一个较小的值，并且有可能和其他行的哈希码不同。它把哈希码保存在索引中，并且保存了一个指向哈希表中每一行的指针。因为索引只包含了哈希码和行指针，而不是值自身，MYSQL不能使用索引中的值来避免读取行。MYSQL不能使用哈希索引进行排序，因为它们不会按序保存行。哈希索引不支持部分键匹配，因为它们是由被索引的全部值计算出来的。也就是说，如果在（A，B）两列上有索引，并且WHERE子句中只使用了A，那么索引就不会起作用。哈希索引只支持使用了= IN（）和<=>的相等比较。它们不能加快范围查询。例如WHERE  price> 100;访问哈希索引中的数据非常快，除非碰撞率很高。当发生碰撞的时候，存储引擎必须访问链表中的每一个行指针，然后逐行进行数据比较，以确定正确的数据。如果有很多碰撞，一些索引维护操作就有可能会变慢。

问题二：接口和抽象类的区别？http://dev.yesky.com/436/7581936.shtml

解析：在Java语言中， abstract class 和interface 是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的 面向对象能力。abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进 行抽象类定义时对于abstract class和interface的选择显得比较随意。其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。本文将对它们之间的区别进行一番剖析，试图给开发者提供一个在二者之间进行选择的依据。 
　　
理解抽象类
　　abstract class和interface在Java语言中都是用来进行抽象类（本文 中的抽象类并非从abstract class翻译而来，它表示的是一个抽象体，而abstract class为Java语言中用于定义抽象类的一种方法， 请读者注意区分）定义的，那么什么是抽象类，使用抽象类能为我们带来什么好处呢？

　　在面向对象的概念中，我们知道所有的对象都是通过类来描绘的，但是反过来却不是这样。并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类往往用来表征我们在对问题领域进行分析、 设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。比如：如果我们进行一个图形编辑软件的开发，就会发现问题领域存在着圆、三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域是不存在的，它就是一个抽象概念。正是因为抽象的概念 在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。

　　在面向对象领域，抽象类主要用来进行类型隐藏。我们可以构造出一个固定的一组行为的抽象描 述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的；同时，通过从这个抽象体派生，也可扩展此模块的行为功能。熟悉OCP的读者一定知道，为了能够实现面向对象设计的一个最核心的原则OCP(Open-Closed Principle)，抽象类是其中的关键所在。

　　从语法定义层面看abstract class 和 interface

　　在语法层面，Java语言对于abstract class和interface给出了不同的定义方式，下面以定义一个名为Demo的抽象类为例来说明这种不同。

　　使用abstract class的方式定义Demo抽象类的方式如下：
abstract class Demo｛abstract void method1();abstractvoid method2();…｝

　　使用interface的方式定义Demo抽象类的方式如下：
interface Demo{void method1();void method2();…}

　　在abstract class方式中，Demo可以有自己的数据成员，也可以有非 abstract的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修改的数据成员（也就是必须是static final 的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的 abstract class。

　　从编程的角度来看，abstract class和interface都可以用来实现 "design by contract" 的思想。但是在具体的使用上面还是有一些区别的。

　　首先，abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系(因为Java不支持多继承 -- 转注)。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。

　　其次，在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface的定义中，方法却不能拥有默认行为，为了绕过这个限制，必须使用委托，但是这会增加一些复杂性，有时会造成很大的麻烦。

　　在 抽象类中不能定义默认行为还存在另一个比较严重的问题，那就是可能会造成维护上的麻烦。因为如果后来想修改类的界面（一般通过 abstract class 或者interface来表示）以适应新的情况（比如，添加新的方法或者给已用的方法中添加新的参数）时，就会非常的麻烦，可能要花费很多的时间（对于派生类很多的情况，尤为如此）。但是如果界面是通过abstractclass来实现的，那 么可能就只需要修改定义在abstract class中的默认行为就可以了。

　　同样，如果不能在抽象类中定义默认行为，就会导致同样的方法实现出现在该抽象类的每一个派生类中，违反了 "one rule，one place" 原则，造成代码重复，同样不利于以后的维护。因此，在abstract class和interface间进行选择时要非常的小心。

　　从设计理念层面看 abstract class 和 interface

　　上面主要从语法定义和编程的角度论述了abstract class和interface的区 别，这些层面的区别是比较低层次的、非本质的。本小节将从另一个层面：abstract class和interface所反映出的设计理念，来分析一下二者的区别。作者认为，从这个层面进行分析才能理解二者概念的本质所在。

　　前面已经提到过，abstract class在Java语言中体现了一种继承关系，要想使得 继承关系合理，父类和派生类之间必须存在"is-a"关系，即父类和派生类在概念本质上应该是相同的。对于interface来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的， 仅仅是实现了interface定义的契约而已。为了使论述便于理解，下面将通过一个简单的实例进行说明。

　　考虑这样一个例子，假设在我们的问题领域中有一个关于Door的抽象概念，该Door具有执行两个动作open和close，此时我们可以通过abstractclass或者interface来定义一个表示该抽象概念的类型，定义方式分别如下所示：

　　使用abstract class方式定义Door：
abstract class Door{abstract void open();abstract void close()；}

　　使用interface方式定义Door：
interface Door{void open();void close();}

　　其他具体的Door类型可以extends使用abstractclass方式定义的Door或者implements使用interface方式定义的Door。看起来好像使用abstract class和interface没有大的区别。

　　如果现在要求Door还要具有报警的功能。我们该如何设计针对该例子的类结构呢（在本例中， 主要是为了展示 abstract class 和interface 反映在设计理念上的区别，其他方面无关的问题都做了简化或者忽略）？下面将罗列出可能的解决方案，并从设计理念层面对这些不同的方案进行分析。

　　解决方案一：
　　简单的在Door的定义中增加一个alarm方法，如下：
abstract class Door{abstract void open();abstract void close()；abstract void alarm();}

　　或者
interface Door{void open();void close();void alarm();}

　　那么具有报警功能的AlarmDoor的定义方式如下：
class AlarmDoor extends Door{void open(){…}void close(){…}void alarm(){…}}

　　或者
class AlarmDoor implements Door｛void open(){…}voidclose(){…}void alarm(){…}｝

　　这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)，在Door的定义中把Door概念本身固有的行为方法和另外一个概念"报警器"的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为"报警器"这个概念的改变（比如：修改alarm方法的参数）而改变，反 之依然。

　　解决方案二：
　　既然open、close和alarm属于两个不同的概念，根据ISP原则应该把它们分别定 义在代表这两个概念的抽象类中。定义方式有：这两个概念都使用 abstract class 方式定义；两个概念都使用interface方式定义；一个概念使用 abstract class 方式定义，另一个概念使用interface方式定义。

　　显然，由于Java语言不支持多重继承，所以两个概念都使用abstract class方式定义是不可行的。后面两种方式都是可行的，但是对于它们的选择却反映出对于问题领域中的概念本质的理解、对于设计意图的反映是否正确、合理。我们一一来分析、说明。

　　如果两个概念都使用interface方式来定义，那么就反映出两个问题：
1、我们可能没有 理解清楚问题领域，AlarmDoor在概念本质上到底是Door还是报警器？
2、如果我们对于问题领域的理解没有问题，比如：我们通过对于问题领域的分析发现AlarmDoor在概念本质上和Door是一致的，那么我们在实现时就没有能够正确的揭示我们的设计意图，因为在这两个概念的定义上（均使用 interface方式定义）反映不出上述含义。

　　如果我们对于问题领域的理解是：AlarmDoor在概念本质上是Door，同时它有具有报 警的功能。我们该如何来设计、实现来明确的反映出我们的意思呢？前面已经说过，abstract class在Java语言中表示一种继承关系，而继承关系 在本质上是"is-a"关系。所以对于Door这个概念，我们应该使用abstarct class方式来定义。另外，AlarmDoor又具有报警功能，说明它又能够完成报警概念中定义的行为，所以报警概念可以通过interface方式定义。如下所示：
abstract class Door{
abstractvoid open();
abstractvoid close()；
}interfaceAlarm{void alarm();}
classAlarm Door extends Door implements Alarm{
voidopen(){…}
voidclose(){…}
voidalarm(){…}
}

　　这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实abstract class表示的是"is-a"关系，interface表示的是"like-a"关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。

　　小结
　　1.abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。
　　2.在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在 interface中一般不定义数据成员），所有的成员方法都是abstract的。
　　3.abstract class和interface所反映出的设计理念不同。其实abstract class表示的是"is-a"关系，interface表示的是"like-a"关系。 
　　4.实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。
　　5.接口中定义的变量默认是public staticfinal 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。
　　6.抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。 
　　7.接口中的方法默认都是 public,abstract 类型的。

　　结论
　　abstract class 和 interface 是 Java语言中的两种定义抽象类的方式，它们之间有很大的相似性。但是对于它们的选择却又往往反映出对于问题领域中的概 念本质的理解、对于设计意图的反映是否正确、合理，因为它们表现了概念间的不同的关系（虽然都能够实现需求的功能）。这其实也是语言的一种的惯用法，希望读者朋友能够细细体会。


## JDK里边的设计模式

http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns

一面（1 hour）：
1. 面试官从简历里抽了一个较感兴趣的项目，让把项目简单介绍了下，针对项目问了几个技术问题
2. 介绍Java中垃圾回收机制，程序员平时需要关注这个吗？为什么？请举例说明。
3. 数据库隔离级别介绍、举例说明。
4. override和overload的区别。
5. 求二叉树的最大距离（即相距最远的两个叶子节点），写代码。
6. 两个栈实现一个队列，写代码。
7. 你觉得你的优势是什么？有什么技术薄弱点吗？
8. 目前手上有offer吗？
二面（40 minutes）：
1. 详细介绍研究生期间的小论文项目。
2. 求二叉树的宽度，先简介思路再写代码。
3. Hashmap、Hashtable和cocurrentHashMap的区别，要讲出它们各自的实现原理才行，比如Hashmap的扩容机制、cocurrentHashMap的桶分割原理、多线程安全性。
4. 进程调度算法，有哪些算法比较难实现？
5. linux下如何修改进程优先级？（nice命令的使用）。
6. linux下性能监控命令uptime介绍，平均负载的具体含义是什么？建议看server load概念。
7. linux下如何调试程序？说到gdb，具体如何调试？如何查看core文件中的堆栈信息等（bt指令）。
三面（1 hour and twenty minutes）：
1. 介绍我研究生期间的论文，讲的很详细，每个点具体采用的技术、实现方法等，花了较长时间。
2. 打印二叉树两个叶子节点间的路径，写代码（汗，百度这么喜欢问二叉树）。
3. 字符串中第一个只出现一次的字符，如何优化算法使得遍历次数更少？
4. socket编程相关，如果服务器这边调用write写了100个字节的数据，客户端想要获得这个数据，是直接用read系统调用，参数也是100吗？
5. 百度新闻缓存预算问题：一般为了追求时间性能，都需要缓存一些新闻数据，你怎么计算所需预算？然后申请需要的主机……
6. 多线程的适用场景是什么？为啥要用多线程？
7. 问是否会go语言，……
8. 为啥对技术感兴趣，一些相关问题讨论。
9. 聊北京、谈offer。
最后面试官说像计算机体系结构、操作系统这样的书一定要看国外的，国内的有时候会误导人。

. Java 的引用类型有哪几种
9. 抽象类和接口的区别
10. 设计模式会哪些
11. 工厂方法模式的优点（低耦合、高内聚，开放封闭原则）
12. 数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）
13. 老年代中数组的访问方式
14. GC 算法，永久代对象如何 GC ， GC 有环怎么处理
15. 谁会被 GC ，什么时候 GC
16. 如果想不被 GC 怎么办
17. 如果想在 GC 中生存 1 次怎么办
18 缓存设计与 LRU
19. hashCode() 与 equals() 生成算法、方法怎么重写
20. 关系型和非关系型数据库区别
21. HBase 原理与工作机制，如何保证 HA ，如何保证宕机数据可恢复
22. 数据库处理大数据的优化
23. 索引的分类
24. 模糊查询性能
25. 排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）
26. 逆波兰计算器
27. Hoffman 编码
28. 查找树与红黑树
29. Spring 框架等
30. 项目
31. jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析
一面总结 ：
面试官竟然主动对我说谢谢 …  惊我一身冷汗，不过立刻意识到肯定过了。
1) 面试问题主要根据自我介绍和项目，所以，对写在简历上的内容，一定要理解的清清楚楚，也不要为了简历看起来牛比而罗列经历，尤其是自己浅尝辄止的项目。
例如，建议不要轻易说自己写过爬虫，因为没那么简单，一般会追问懂 Scrapy 框架吗，为什么不做成分布式的，如何并行爬取多个网站，如何设计并行任务分发器，爬来的数据如何存储，索引，检索，你觉得还有什么可以改进的。爬虫属于搜索引擎框架的一部分，面试爬虫很容易给自己挖一个 “ 系统设计 ” 的坑。
2) 阿里注重基础、潜力和兴趣，而一些初创公司往往更注重立即上手的技能，这一点在面试中有所体会。
3) 阿里注重基础，但是仅有基础是不够的。
项目经历与实习经历可以加分，一线互联网公司的实习经历可以镀金，由于师门严禁实习，因此需要项目弥补，除去研究的课题多目标优化算法， Hadoop 是个“大宝贝”，它包含了 java 、 jvm 、设计模式、大数据处理框架、分布式计算、 HA 、负载均衡、主备一致性等，也包含分布式文件系统、分布式计算框架、非关系型数据库的实现等，几乎面试官问的任何场景的问题，都可以在 Hadoop 中找到解答，所以， Hadoop 是我最大的加分项，弥补了自己零实习的弱点。
至于 Hadoop 需要掌握到什么程度，才能应对面试？原理上，可以回答上面提到的点，操作上，自己可以实现淘宝的数据魔方的 Demo 。
4) 面试官的问题不会了怎么办？个人不建议直接说不会，而是要 “ 扯 ” 。
例如，问我 Spring 、 iBatis 等框架，而我一点不懂，但我说会 Hadoop ，你有什么业务需求，我几乎都可以在 Hadoop 找到实现。问我 MySQL 数据库，我也不精通，但我会告诉他 HBase 如何解决。
5) 关注面试的公司，关注阿里的开源技术与自主框架，例如，问到 jvm 的时候，我会向面试官阐述淘宝在 jvm 方面的优化工作，以及 jvm 在 Hadoop 方面的优化。有兴趣的同学可以关注淘宝 “ 莫枢 ” ，后离职加入 Oracle 、 Azul ，在虚拟机方面做了很多出色的工作，详情关注： ITeye 的高级语言虚拟机专栏。
6) 回答问题时，切忌使用 “ 应该 ” 、 “ 好像 ” 、 “… 吧 ” 等不确定性词汇，因为搞技术还是需要严谨的，面试官不想招聘一个什么都靠猜测的同事。

二面 ：
时间约 23 分钟，感觉是交叉面，是其他部门的主管，听语气感觉级别在 P8 以上。
首先也是自我介绍，针对自我介绍和项目，开始提问。
1. IO 流，字节流 --> 字符流
2. 递归读取文件夹下的文件，代码怎么实现
3. HashMap 与线程安全问题
4. rehash
5. Web 框架
6. 项目与 Hadoop
7. 问我未来的职业规划
8. 问我有什么问题（问了关于阿里工程师文化的问题）
二面总结 ：
1) 自我介绍要抓住重点，与岗位匹配，比如面技术，社团经历可以不说（但是 hr 面非常有用）。
2) 二面问的技术内容很少，感觉是可以看到一面成绩，进行简单的确认。所以，笔试或一面表现好，对后面的面试很有帮助。
3) 当面试官不再关注你的过去，而是和你谈未来谈理想的时候，基本表明面试通过了。例如，问职业规划和你对阿里的想法等问题的时候。

hr 面 ：
知乎上称阿里的 hr 是神存在，掌握生杀大权，多少英雄好汉历经残酷的技术面，却倒在 hr 面前，但是从个人的经历，感觉 hr 姐姐还是很 nice 的。
40 分钟，并没有自我介绍，而是直接轰炸。
1. 暑假在学校做什么呢
2. 平时喜欢阅读什么书
3. 问我俱乐部主席的工作，有什么收获（社团主席，是 hr 的兴趣点）
4. 课题是什么，遇到什么困难，你是如何解决问题的
5. 为什么不从事本专业相关工作
6. 你专业是电磁场，为什么要转行
7. 你是一个什么样的人
8. 你的缺点
9. 曾经最大的打击
10. Web 框架不会怎么办，以后工作的内容和你现在研究的不同怎么办
11. 职业规划
12. 如果能去杭州家人同意吗
13. 向我介绍了所应聘部门
14. 问我有什么问题
hr 面总结 ：
1) 一定要坦诚， hr 阅人无数，更别说阿里的 hr 了。
2) 面试官是在考察适合自己团队的人选，而面试者，也是在寻找适合自己的团队和 manager ，这是双向选择的过程，所以自己的心态要和面试官持平。记住，面试官是在寻找团队伙伴，不是在对你考试，这种心态有助于减轻紧张的心情。
3) 社团经历对自己的成长，看不见摸不着，但在时间管理、情绪控制、团队管理等方面，有很大的收获。程序猿的工作寿命并不长，当技术过硬，开始带团队的时候，相信一定会感谢自己在社团的经历。


一轮技术面：
　　coding题目
　　（1）把IP地址转换成INT型存储（考察的位运算）
　　（2）给一个概率发生器p的概率是0，1-p的概率是1：如何构造一个0.5的概率发生器（简单概率问题）
　　机器学习题目：
　　（1）SVM推导过程
　　（2）GradientDescent如何做并行化
　　（3）多线程问题
　　狼厂实习经历回顾，简单提问。
　　一轮完毕。（耗时大概50分钟）

二轮技术面：
　　简单看简历上的排名和成绩。
　　coding题目
　　（1）如何求n!的最后一个非零位的数字（假设n是很大的数字，n!无法计算）
　　（2）写一个简单的mapreduce job完成score统计和排序（我用python脚本写的）
　　（3）给定一个数轴，数轴上有间距不等的若干个点；再给定一个长度固定的标尺；问这个长度固定的标尺最多能囊括数轴上几个点（要求O(n)时间复杂度，O(1)空间复杂度）
　　机器学习题目
　　（1）LogisticRegression推导（很多细节）
　　（2）L1 L2正则化都是什么，怎么调参（感觉面试官非常关注细节，而且也懂细节）
　　（3）如何做LR模型学习的并行化
　　实验室做过的项目，以及实习做过的项目的面试
　　二轮完毕。（耗时大概50分钟）

三轮经理面：
　　经理貌似比较关心学校的排名和成绩（可能可以体现一个人的学习水平）
　　谈谈对本部门产品的理解和看法，有什么改进的。
　　什么时候能来实习，学校还有什么事情。
　　有什么需要问的（我主要关心部门发展的点以及近期发力的方向）
　　三轮面试完毕。（耗时20分钟）
整个面试过程，算上中间的休息，大概2个半钟头。

给我的感觉是狼厂的面试官非常专业敬业，但不会特别难为人。
（1）技术面的时候问我是否搞过ACM，我诚实相告没有搞过，面试官出的coding题目就侧重一些基础了，没有太难为人的。
（2）面试官对于一些细节比较在意，感觉是真心想考察一个人对知识掌握的是否透彻，并不是走马观花。
（3）补充一点，感觉面试的时候，所使用的语言并不是最关键的（当然，如果能match应聘部门的常用开发语言是最好的了）；除了能完成基本的算法coding，面试官还关心的是写代码的基本功（比如变量的命名、一些corner cases的处理是否全面）。

.链表判断环路和查找连接点；2.两个栈实现队列，如何实现多线程并发；3.两个串任意合并是否可以成为第三个串。（参考：http://www.cnblogs.com/yu-chao/archive/2012/02/26/2369052.html）

1.linux内核态和用户态，为什么要这么分？
2.多重继承为什么会含有多个虚表指针而不是一个？
3.tcp和udp的区别，tcp是怎么做错误处理的？

一、Java基础
1.String类为什么是final的。
2.HashMap的源码，实现原理，底层结构。
3.反射中，Class.forName和classloader的区别
4.session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。
5.Java中的队列都有哪些，有什么区别。
6.Java的内存模型以及GC算法
7.Java7、Java8的新特性(baidu问的,好BT)
8.Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高
9.Java内存泄露的问题调查定位：jmap，jstack的使用等等

二、框架
1.struts1和struts2的区别
2.struts2和springMVC的区别
3.spring框架中需要引用哪些jar包，以及这些jar包的用途
4.srpingMVC的原理
5.springMVC注解的意思
6.spring中beanFactory和ApplicationContext的联系和区别
7.spring注入的几种方式
8.spring如何实现事物管理的
9.springIOC和AOP的原理
10.hibernate中的1级和2级缓存的使用方式以及区别原理
11.spring中循环注入的方式

三、多线程
1.Java创建线程之后，直接调用start()方法和run()的区别
2.常用的线程池模式以及不同线程池的使用场景
3.newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。
4.多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。
5.了解可重入锁的含义，以及ReentrantLock 和synchronized的区别
6.同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高
7.atomicinteger和volatile等线程安全操作的关键字的理解和使用
8.线程间通信，wait和notify
9.定时线程的使用
10.场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。

四、网络通信
1.http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。
2.socket通信，以及长连接，分包，连接异常断开的处理。
3.socket通信模型的使用，AIO和NIO。
4.socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。
5.同步和异步，阻塞和非阻塞。

五、Linux
1.常用的linux下的命令
2.大的log文件中，统计异常出现的次数、排序，或者指定输出多少行多少列的内容。(主要考察awk)
3.linux下的调查问题思路：内存、CPU、句柄数、过滤、查找、模拟POST和GET请求等等场景
4.shell脚本中#！的作用

六、数据库MySql
1.MySql的存储引擎的不同
2.单个索引、联合索引、主键索引
3.Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)
4.分表之后想让一个id多个表是自增的，效率实现
5.MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离
6.写SQL语句。。。
7.索引的数据结构，B+树
8.事物的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题

七、设计模式(写代码)
1.单例模式：饱汉、饿汉。以及饿汉中的延迟加载
2.工厂模式、装饰者模式、观察者模式。

八、算法
1.使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）
2.两个有序数组的合并排序
3.一个数组的倒序
4.计算一个正整数的正平方根
5.说白了就是常见的那些查找排序算法（排序转载：http://mp.weixin.qq.com/s?__biz= ... 48a3&scene=5#rd）

九、缓存
1.为什么用缓存，用过哪些缓存，redis和memcache的区别
2.redis的数据结构
3.redis的持久化方式，以及项目中用的哪种，为什么
4.redis集群的理解，怎么动态增加或者删除一个节点，而保证数据不丢失。（一致性哈希问题）


简单描述一下滑动窗口和拥塞避免？  这个考概念了。

4、32的jvm可以跑多大的程序？ 理论上来说32位的JVM有4G的堆大小限制。但是因为各种条件限制比如交换区，内核地址空间使用，内存碎片，虚拟管理机的管理开销，实际上可用的堆的大小远远比理论上的4G要少。 在32位windows的机器上，堆最大可以达到1.4G至1.6G。 在32位solaris的机器上，堆最大可以达到2G 而在64位的操作系统上，32位的JVM，堆大小可以达到4G 

5、http的post和get方法性能上的区别
1. get是从服务器上获取数据，post是向服务器传送数据。
2. get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。
3. 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。
4. get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。5. get安全性非常低，post安全性较高。但是执行效率却比Post方法好。
 
建议：
1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；
2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；

6、学习过哪些开源的框架
7、mybatis的使用方式
 

1，不使用第三个数（临时变量）交换两个整形数
提示：方式1加法，a=a+b;b=a-b;a=a-b;(缺点，可能出现a+b超过范围)；方式2位运算，a^=b;b^=a;a^=b;(对数值类型通用)
2，0000到9999这1万个数中有多少个数字7（请不要理解为多少个数包含7）
提示：方式1，可以通过找规律的方式，比如1到10，1到100，1到1000分别多少个7；方式2，对每一位单独考虑，共四位，每一位出现7的概率是1/10；方式3，每次固定一位，变换其他位，比如固定千位为7，那么就有1000个，依次计算，得到最终结果4000
3，如何实现一个随机播放音乐，要求能够方便查看上一首播放的是什么，方便交换即将播放的歌曲顺序
提示：先对歌曲编号为0~999（比如有1000首歌），用洗牌算法（不懂的请自行百度）将序号顺序打乱，之后开始播放，这样播放中用户可以对歌曲再次调整顺序，调整时同步调整序号。
4，6根火柴能最多摆出多少等边三角形
提示：正六角星（8个等边三角形）
5，如何实现俄罗斯方块游戏形状的移动和旋转
提示：先用矩形将下落方块围住标记，再记录方块当前的左下角位置，移动时记录坐标变化（可以百度看更高端的答案）
6，tcp连接过程
提示：答出三次握手、四次挥手分别发送了什么内容、处于什么状态(最好一边画图一边解释)
7，tcp流量控制
提示：答出滑动窗口，拥塞控制，慢启动，可以附带答上快重传、快恢复和超时重传（显得自己知道的比较多咯）
8，SendMessage与PostMessage的区别
提示：从阻塞和非阻塞的角度答，也可以结合windows消息机制中的WM_COPYDATA方式的进程间通信答（此处只能由SendMessage()发送）
9，截图软件如何实现（关于自己做的）
提示：这个作为了解就行，毕竟只是我自己做着玩他看到了就问的。通过GDI获取图形缓冲区位图数据，再通过相应库函数将位图数据转换为JPG压缩数据保存，再实现全局热键设定，监控键盘热键是否按下。
10，图像滤波方法及特点（关于项目）
提示：同上。均值滤波，中值滤波，高斯滤波等


面了30分钟就说到这里了，没让我问他问题。
9月15中午查微信状态变为复试，晚8点半通知参加二面。
9.16 早上9点半  二面（压力面）   30min
二面之所以叫压力面，就是全程会让你很大压力（当然这点对很牛的大神0点伤害）。反正我的二面过程中感觉比较压抑，虽然面试官看起来比较温和，但是句句咄咄逼人，从鄙视我的学校开始（普通一本院校。。），然后说我高考肯定考的不好。
全程并没有让我写代码之类（不知道是不是特例，我本以为会让写代码的），问了较多简历上相关的东西，但是一直不对我持肯定态度，要么质疑要么沉默，只让思考了一个正规点的题目，就是说出1到1000里有多少个7（只能说和一面的重复了，无语...）。
不过也问了蛮多生活中学习的例子，比如怎么解决新问题，经常看什么论坛和博客，看到了什么内容（分享给他），然后问c++对比c除了抽象还有一些什么新特性（不管我回答什么，如果有问题，就直接提出，没有他就一脸沉默，不过大概这就是制造心理压力吧）。
面完之后我自我感觉并不好，最后没让我问他问题，我冒昧的问了他我的表现，让他做一下评价，他说我是第一个不好做评价，要等所有面试完了他才筛选。
ps：建议自己简历上的一定要有深层的准备，感觉他问了一些关于我项目中的非常规问题，然后看随机应变能力，还有要保持平和心态，把自己想说的表达清楚。二面下来可能会觉得很差，但是不要气馁，也许只是中了他的招，边等通知边准备其他面试吧，别太受伤~
pps：我面试中没有让写代码，这个可能是特例，常见写代码的面试题还是要准备的，以剑指offer，程序员面试金典，编程之美这几本书为主，完全掌握之后笔试中面试题基本都是小case了（ppps:不过我还没看完，囧）
因为压力面的确有蛮大压力，本以为过的几率不大，继续准备百度面试了，然后在9月16号中午微信状态变为进入hr面，晚上7点收到三面通知。
9月17 中午2点半  hr面（也是终面）   20min
hr面就比较轻松了，让我做了一下简单的自我介绍（终于碰到自我介绍的了。）然后开始对着简历问一些深入的问题，不一定关于技术的，但是和项目和实习经历有关，问你遇到了哪些问题，怎么解决的。为什么选择这个职位（然后悲剧的发现tx的系统出了问题，把我的职位搞错了，他说帮我联系复试面试官给我确认职位，蛮温和的），考不考研（楼主答不考研，原因balabala...此处省略若干字），为什么不考研。之后问了一些生活上学习上之类的问题，就问我还有什么要问的，这个自己把握好问题就行，把提前准备的问题说出来。
回来后不久微信上查询的状态就变为已完成所有面试环节了，据淼姐表示，hr面基本不刷人的，有少部分人hr面之后状态会变为“你不适合该职位”，如果是这个状态就不妙了~
