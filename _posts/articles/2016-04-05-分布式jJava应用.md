---
layout: article
title: "分布式Java应用"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: 4002502.jpg
  thumb:
date: 2016-04-07T08:52:29+08:00
---

{% include toc.html %}

{% highlight java %}

{% endhighlight %}

## 同步异步的理解

同步就是只能A走完某一段然后停下，让B开始走一段再停下，再让A走。。如此往复。简单理解就是，必须是一段程序执行完后才能执行后面的程序。。
异步就是，同一时间可能A和B同时都在往终点赶，此时不存在先后顺序，就是说，两个程序可以同时执行，称为异步。。

举个例子：普通B/S模式（同步）AJAX技术（异步）   

同步：提交请求->等待服务器处理->处理完毕返回   这个期间客户端浏览器不能干任何事   

异步:请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

以通讯为例   

同步:发送一个请求,等待返回,然后再发送下一个请求 
  
异步:发送一个请求,不等待返回,随时可以再发送下一个请求   

并发:同时发送多个请求

## 分布式Java应用有两种典型的方法来实现

### 基于消息方式实现系统间的通信

当系统之间要进行通信时，就要向外发送消息，消息可以使字节流、字节数组、甚至是Java对象

常见的实现系统间通信协议有：TCP/IP和UDP/IP,这两种协议可用于完成系统间的通信，但需要对数据进行处理，还需要对数据进行处理，例如读取数据和写入数据，可以分为同步IO和异步IO，其中同步IO分为BIO(Blocking IO)和NIO(Non-Blocking IO)。

BIO就是发起IO的读写操作时，均为阻塞方式，只有当程序读到了流或者将流写入操作系统后，才会释放资源。

NIO是基于事件驱动思想的，实际上采用的是Reactor模式，从程序员的角度，当发起IO的读或者写操作时，是非阻塞的。当Socket有流可以写入Socket时，操作系统为通知相应的应用程序处理。

AIO为异步IO方式，也是基于事件驱动的思想，从程序员角度与AIO不同，当进行读或者写操作时，只需直接调用API的read或write方法即可，这两种方法均为异步的。与NIO不同，AIO简化了程序的编写，流的读取和写入都是由操作系统来代完成的，另一方法省去了NIO中程序要遍历事件通知队列的代价。

### 基于远程调用方式实现系统间通信

当系统之间要进行通信时，可以通过调用本地Java接口的方法，透明的调用远程的Java实现，具体的实现细节由Java或者框架完成，这种方式在Java中主要实现基于RMI和WebService的应用。

## 基于消息方式实现系统间通信（详细）

### 基于Java自身技术实现消息方式的系统间通信

基于Java吱声包实现消息方式有TCP/IP UDP/IP BIO NIO排列组合的四种

#### TCP/IP+BIO

Java中可基于Socket、ServerSocket来实现TCP/IP+BIO系统间通信。Socket主要用于实现建立连接及网络IO操作，ServerSocket主要用于实现服务器端口的监听以及Socket对象的获取。

Socket实现客户端的关键：

{% highlight java %}

package book.chapter1.tcpbio;
/**
 * 《构建高性能的大型分布式Java应用》
 *  书中的示例代码
 *  版权所有   2008---2009
 */
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

/**
 * 描述：基于java实现TCP/IP+BIO方式的网络通讯示例，此为客户端代码
 *
 * @author bluedavy 
 * 
 * 创建时间： 2008-11-27
 */
public class Client {

	/**
	 * @param args
	 */
	public static void main(String[] args) throws Exception{
		String host="127.0.0.1";
		int port=9527;
		//目标IP或者域名，目标端口
		Socket socket=new Socket(host,port);
		//创建读取服务器端返回流的buffer
		BufferedReader in=new BufferedReader(new InputStreamReader(socket.getInputStream()));
		//创建向服务器写入流的PrintWriter
		PrintWriter out=new PrintWriter(socket.getOutputStream(),true);
		BufferedReader systemIn=new BufferedReader(new InputStreamReader(System.in));
		boolean flag=true;
		while(flag){

			//在控制台读取
			String command=systemIn.readLine();
			if(command==null || "quit".equalsIgnoreCase(command.trim())){
				flag=false;
				System.out.println("Client quit!");
				out.println("quit");
				out.close();
				in.close();
				socket.close();
				continue;
			}

			//像服务器发送字符串信息，要注意的是即使写失败也不会抛出异常，并且会一直阻塞到写入操作系统或网络出现IO异常为止
			out.println(command);

			//服务器返回的信息，若希望过一段时间不在阻塞了可以在创建Socket后调用Socket.settimeout
			String response=in.readLine();
			System.out.println(response);
		}
	}
	
}
{% endhighlight %}

服务器端：

{% highlight java %}

package book.chapter1.tcpbio;
/**
 * 《构建高性能的大型分布式Java应用》
 *  书中的示例代码
 *  版权所有   2008---2009
 */
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * 描述：基于java实现TCP/IP方式的网络通讯示例，此为服务器端代码
 *
 * @author bluedavy 
 * 
 * 创建时间： 2008-11-27
 */
public class Server {

	/**
	 * @param args
	 */
	public static void main(String[] args) throws Exception{
		int port=9527;

		//监听端口
		ServerSocket ss=new ServerSocket(port);
		System.out.println("Server listen on port: "+port);

		//接受客户端建立连接的请求
		Socket socket=ss.accept();

		//接受客户端数据
		BufferedReader in=new BufferedReader(new InputStreamReader(socket.getInputStream()));

		//写回客户端
		PrintWriter out=new PrintWriter(socket.getOutputStream(),true);
		while(true){
			String line=in.readLine();
			if(line==null){
				Thread.sleep(100);
				continue;
			}
			if("quit".equalsIgnoreCase(line.trim())){
				in.close();
				out.close();
				ss.close();
				System.out.println("Server has been shutdown!");
				System.exit(0);
			}
			else{
				System.out.println("Message from client: "+ line);
				out.println("Server response："+line);
				Thread.sleep(100);
			}
		}
	}
	
}

{% endhighlight %}

上边是基于Socket、ServerSocket实现的一个简单的系统间通信的例子，而在实际系统中，面对多个用户同时发送请求到服务器端，服务器要同时接受多个连接发送的请求。

为了满足客户多能发送多个请求到服务器端最简单的方法就是生成多个Socket。但这会导致两个问题：一是生成多个Socket会消耗太多的系统资源，在客户端多服务器端少的情况下客户端生成太多的Socket会导致服务器需要支撑太多的连接数；二是生成Socket（建立连接）通常是比较慢的，创建频繁会导致系统性能不足。可以采用连接池的方式解决这个问题，一方面限制了Socket的数量，另一方面避免重复创建Socket带来的性能问题。

为了满足服务器能够满足多个连接请求，通常采用的办法是在accept获取Socket之后，将Socket放入一个线程中处理，通常将这种方式叫做一连接一线程，这样就可以接受多个请求了，但是会耗费线程，为了避免服务器资源耗尽的情况必须限制线程的数量，因此也就限制了服务器连接线的个数。

#### TCP/IP+NIO