---
layout: article
title: "leetcode基本树第一部分"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: leetcode.jpg
  thumb:
date: 2016-03-06T11:50:29+08:00
---

{% include toc.html %}

# 前序遍历

1、什么是前序遍历？父节点在子节点前运行

2、使用java核心库中的栈

在一些情况下前序遍历并不是那么的明显。但是如果你画出一个栈图手动的执行程序，你就能看到每一元素是如何进和如何出的。

解决这个问题的关键是使用栈来存储左孩子和右孩子，并且把右孩子先压入栈以确保左孩子先被处理

{% highlight java %}

package algorithm.sort;
 
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}
 
public class Solution {
    public ArrayList<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> returnList = new ArrayList<Integer>();
 
        if(root == null)
            return returnList;
 
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);
 
        while(!stack.empty()){
            TreeNode n = stack.pop();
            returnList.add(n.val);
 
            if(n.right != null){
                stack.push(n.right);
            }
            if(n.left != null){
                stack.push(n.left);
            }
 
        }
        return returnList;
    }
}

{% endhighlight %}

# 中序遍历

1、中序遍历的顺序是左孩子->父节点—>右孩子

2、使用栈来追踪节点

3、在[这个文章](http://www.programcreek.com/2012/12/leetcode-solution-of-binary-tree-inorder-traversal-in-java/)中有图帮助理解

{% highlight java %}
//定义一个二叉树
public class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode(int x) { val = x; }
 }
 
public class Solution {
    public ArrayList<Integer> inorderTraversal(TreeNode root) {

        //用来存放节点中的值
         ArrayList<Integer> lst = new ArrayList<Integer>();
 
        if(root == null)
            return lst; 
 
        Stack<TreeNode> stack = new Stack<TreeNode>();
        //定义一个指针来追踪节点
        TreeNode p = root;
 
        while(!stack.empty() || p != null){
 
            // 如果不为空，把他放入到栈中，去到坐节点中
            if(p != null){
                stack.push(p);
                p = p.left;
 
            //如果没有左孩子，取出这个节点，并处理这个节点，然后指向右节点
            }else{
                TreeNode t = stack.pop();
                lst.add(t.val);
                p = t.right;
            }
        }
 
        return lst;
    }
}
{% endhighlight %}

递归方案

{% highlight java %}
public class Solution {
    List<Integer> result = new ArrayList<Integer>();
 
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root !=null){
            helper(root);
        }
 
        return result;
    }
 
    public void helper(TreeNode p){
        if(p.left!=null)
            helper(p.left);
 
        result.add(p.val);
 
        if(p.right!=null)
            helper(p.right);
    }
}
{% endhighlight %}

# 后续遍历

在前中后遍历中，后续遍历是最复杂的

1、后续遍历的顺序是：左孩子->右孩子->父节点

2、找到当前节点和先前访问节点间的关系

3、使用栈来追踪节点

当我们访问树的左边时，检查先前访问的节点，如果当前节点是先前节点的左孩子或者右孩子，那么继续沿着树向下走，在栈中增加左右节点。当当前节点没有孩子的时候，例如，当前节点是叶子，那么就从栈中取出。那么下一个循环中先前的节点就变成了当前的节点。[文章](http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/)中有很好的的解释

{% highlight java %}

//Definition for binary tree
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}
 
 
public class Solution {
    public ArrayList<Integer> postorderTraversal(TreeNode root) {
 
        ArrayList<Integer> lst = new ArrayList<Integer>();
 
        if(root == null)
            return lst; 
 
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);

        //先前节点
        TreeNode prev = null;

        while(!stack.empty()){

            //当前节点
            TreeNode curr = stack.peek();
 
            //遍历树，检查当前节点是为叶子节点，如果是的话，弹出并处理它，如果不是继续遍历
            //压入时
            if(prev == null || prev.left == curr || prev.right == curr){
                //prev == null 是根节点的情况
                if(curr.left != null){
                    stack.push(curr.left);
                }else if(curr.right != null){
                    stack.push(curr.right);
                }else{
                    stack.pop();
                    lst.add(curr.val);
                }
 
            //沿着左节点遍历树，需要检查是否有右节点，如果有的话，压入栈，否则的话弹出并处理父节点
            //取出时
            }else if(curr.left == prev){
                if(curr.right != null){
                    stack.push(curr.right);
                }else{
                    stack.pop();
                    lst.add(curr.val);
                }
 
            //从右节点遍历树，从右节点回来之后，弹出并处理父节点
            }else if(curr.right == prev){
                stack.pop();
                lst.add(curr.val);
            }
 
            prev = curr;
        }
 
        return lst;
    }
}

{% endhighlight %}

# 层次遍历（从上到下）

给出一个二叉树，返回层次遍历节点的值（从左到右、从上到下，一层一层进行）

例如给出二叉树{3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7

返回层次遍历的顺序是 [[3], [9,20], [15,7]]

很明显解决这个问题，可以使用队列。但是如果我们使用一个队列，我们不能追踪每一层从哪里开始，所以我们使用两个队列追踪当前的层和下一个层。

{% highlight java %}

// linkedlist.remove() 移除当前对象

public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
    ArrayList<ArrayList<Integer>> al = new ArrayList<ArrayList<Integer>>();
    ArrayList<Integer> nodeValues = new ArrayList<Integer>();
    if(root == null)
        return al;
 
	//两个队列
    LinkedList<TreeNode> current = new LinkedList<TreeNode>();
    LinkedList<TreeNode> next = new LinkedList<TreeNode>();
    current.add(root);
 
	//当前的节点不为空
    while(!current.isEmpty()){
		
		//取出当前节点
        TreeNode node = current.remove();
 
		//左右节点不为空，加入到下一层中去
        if(node.left != null)
            next.add(node.left);
        if(node.right != null)
            next.add(node.right);
 
		//把节点的值加入进去
        nodeValues.add(node.val);
        if(current.isEmpty()){
            current = next;
            next = new LinkedList<TreeNode>();
            al.add(nodeValues);
            nodeValues = new ArrayList();
        }
 
    }
    return al;
}

{% endhighlight %}


# # 层次遍历（从下到上）

{% highlight java %}

//linkedlist.offer和add方法一样，只不过为空时add会报错，offer返回false

//linkedlist.poll返回列表头元素
public List<ArrayList<Integer>> levelOrderBottom(TreeNode root) {
    ArrayList<ArrayList<Integer>> result = new  ArrayList<ArrayList<Integer>>();
 
    if(root == null){
        return result;
    }
 
    LinkedList<TreeNode> current = new LinkedList<TreeNode>();
    LinkedList<TreeNode> next = new LinkedList<TreeNode>();
    current.offer(root);
 
    ArrayList<Integer> numberList = new ArrayList<Integer>();
 
    //需要记录从那开始的
    while(!current.isEmpty()){
        TreeNode head = current.poll();
 
        numberList.add(head.val);
 
        if(head.left != null){
            next.offer(head.left);
        }
        if(head.right!= null){
            next.offer(head.right);
        }
 
        if(current.isEmpty()){
            current = next;
            next = new LinkedList<TreeNode>();
            result.add(numberList);
            numberList = new ArrayList<Integer>();
        }
    }
 
    //返回 Collections.reverse(result);
    ArrayList<ArrayList<Integer>> reversedResult = new  ArrayList<ArrayList<Integer>>();
    for(int i=result.size()-1; i>=0; i--){
        reversedResult.add(result.get(i));
    }
 
    return reversedResult;
}

{% endhighlight %}


# 后续遍历

{% highlight java %}
{% endhighlight %}

