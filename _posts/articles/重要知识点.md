---
layout: article
title: "重要知识点（不完全）"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: 4002502.jpg
  thumb:
date: 2016-03-08T22:00:29+08:00
---

{% include toc.html %}

① java的内存模型？

② 垃圾回收机制

③ 并发，锁

④ object类中有什么方法？（之前还看过一次，结果临场只说了6个，漏了finalize()、getClass()，居然漏了toString()。。。）

⑥ 常用排序的优缺点和适用情况

项目的问题

kmp算法

SQL语句

JVM结构 

找出一个大文本大的top3字符串

淘宝用户的数据（购物车放在哪里），怎么满足高并发

输入两个数组，返回一个数组：两个数组中的公共值

写一个函数，输入int型，返回整数逆序后的字符串。如：输入123，返回“321”。 要求必须用递归，不能用全局变量，输入必须是一个参数，必须返回字符串。”

项目经历

很多人进入HR面试还是有很大可能被淘汰

struct2是怎么实现的，原理是什么

session是怎么实现的

java怎么创建链表的

ArrayList和LinkedList有什么区别

int类型的数据是32位的，怎么知道一个32位的二进制数据有多少个1

互斥、信号量、进程、线程

hash函数相关的

一个数组存有很多个字母，怎么知道26个字母中的那个没有存储

IOC是什么，内部是怎么实现的，写一下伪代码

AOP呢？

代理模式知道吗，利用JDK自带的类写一个代理模式

银行排队算法是什么

Ehcache源码

说说红黑树的特点和性能

说说JDK中类的源码

写个单列模式

并发的方法知道哪些

比较一些阿里、微软中国、腾讯等公司，技术方面的差异

堆栈的区别

问你所用过的框架中，你比较喜欢那个，为什么

哪个项目中的收获最大，收获到什么

servlets的生命周期

spring的两个主要特性（AOP和IOC）

说说你所理解的J2EE是什么

Hibernate的优点和缺点

你所知道的MVC框架还有哪些

大量数据访问如何实现并发和同步

答：采用乐观锁的方式，大数据如果访问十分频繁乐观锁不断失败可能导致线程饥饿的情况 还可以用读写锁和分段锁

window上的程序如何转移到linux上，需要做哪些改动，你怎么看待linux？

答：重新编译程序 对系统调用方面的函数做相应的修改，linux是个非常棒的系统 稳定 开源 免费 （个别商业版除外）

window32位和window64的区别。

答：最基本的区别是32位的指针大小是4byte 64位为8byte内存寻址范围也不同

数据库的死锁如何解除

structs2是怎么实现的

sql优化 

如何优化JVM

各种mysql数据库引擎的却别

threadlocal，

一致性hash算法原理

写程序实现“2000W用户根据年龄排序”的问题

剑指名企offer

String为什么要设计成为final对象

comparable和comparator的区别

IO/NIO的区别

常见并发包下的类实现

线程池各参数的调整

JVM内存模型

AOP（多种动态代理实现）

缓存（各缓存的区别，实现原理）

消息（JMS机制，主从部署备份实现等），

zookeeper选举算法，

dubbo框架，

各种序列化框架，

一致性hash，

倒排索引原理实现等。

面的问题都是我简历里面写的，特别是写的熟练掌握，深入理解的点全部会重点问，直到最底层的实现

java内存模型

各种垃圾回收算法

分布式事务

类加载器

volatile和syschonized的底层实现原理

答：最基本的区别是32位的指针大小是4byte

简述快速排序 

传递参数时，什么时候是值传递，什么时候是引用传递 

Jdk1.8新特性,

Spring的原理，事务如何管理，如何防止脏读数据, 

说说方法sysnchrnized 和方法块sysnchrnized区别, 

Hibernate的延迟加载，session何时开启，何时关闭. 

对java应用的内存处理机制，线程工作原理，并有没有在项目中实际解决该类问题的经验； 

有没有在项目中有过系统性能调优，性能跟踪，内存泄漏定位等相关经验，
 
在解决实际问题时，是否有了解解决问题方法的本质（解决方案的系统原理）；
 
对关系型数据库工作原理，以及关键性能影响点的了解及项目中的实际经验； 

string，stringbuffer 和stringbuilder的区别 

struts1和2的区别 

ArrayList,HashMap,HashTable区别 

谈谈NIO 

OBJECT有些什么函数，都是做什么用的 

JSP,SERVLE是线程安全的吗？为什么？ 

说出Servlet的生命周期，并说出Servlet和CGI的区别

答：Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。

说出ArrayList,Vector, LinkedList的存储性能和特性 

答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 

HashMap和Hashtable的区别

答：HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 

sleep() 和 wait() 有什么区别? 

答：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

同步和异步有何异同，在什么情况下分别使用他们？举例说明。 

答：如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 

abstract class和interface有什么区别? 

答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 
　接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。 

forward 和redirect的区别 

答：　forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 
    redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。 
	
GC是什么? 为什么要有GC? 

答：GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 
  
编程题: 写一个Singleton出来。 

答：
　Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 
一般Singleton模式通常有几种种形式: 
　第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。 

public class Singleton { 
private Singleton(){} 
　　    //在自己内部定义自己一个实例，是不是很奇怪？ 
　　    //注意这是private 只供内部调用 
　　    private static Singleton instance = new Singleton(); 
　　    //这里提供了一个供外部访问本class的静态方法，可以直接访问　　 
　　    public static Singleton getInstance() { 
　　　　    return instance; 　　 
　　    } 
    }  


    第二种形式: 

public class Singleton { 
　　private static Singleton instance = null; 
　　public static synchronized Singleton getInstance() { 
　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　 　 
　　//使用时生成实例，提高了效率！ 
　　if (instance==null) 
　　　　instance＝new Singleton(); 
return instance; 　　} 
} 


其他形式: 
定义一个类，它的构造函数为private的，所有方法为static的。 
一般认为第一种形式要更加安全些 

请说出你所知道的线程同步的方法。

答：
wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 
Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 

多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 

答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 
同步的实现方面有两种，分别是synchronized,wait与notify 

答：线程的基本概念、线程的基本状态以及状态之间的关系 
　线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。
Java中的线程有四种状态分别是：运行、就绪、挂起、结束。

java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
 
答：有两种实现方法，分别是继承Thread类与实现Runnable接口 
用synchronized关键字修饰同步方法 
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。

启动一个线程是用run()还是start()? 

答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 
run()方法:在本线程内调用该Runnable对象的run()方法，可以重复多次调用；
start()方法:启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程；

HashCode的作用是什么？ 

答：HashCode就是一个散列码，用来在散列存储结构中确定对象的存储地址。HashMap，HashSet，他们在将对象存储时，需要确定它们的地址，而HashCode就是做这个用的。在默认情况下，由Object类定义的hashCode方法会针对不同的对象返回不同的整数，这一般是通过将该对象的内部地址转换成一个整数来实现的。 

Hash算法？ 

答：HashCode是用来查找用的，它可以提高查找效率。举例说： 
内存中有0，1，2，3，4，5，6，7…，N一共N+1个位置可以存储对象，然后类中有个字段叫ID，如何确定这个对象在内存中的存储位置呢？用ID%(N+1)得到的余数就是存储的位置，当要查找这个对象的时候，只需要将ID%(N+1)的余数得到，就可以立即找到这个对象，大大提高了查找效率。 

为什么实现了equals()方法后必须重写hashCode()方法？ 

答：由于java.lang.Object的规范，如果两个对象根据equals()方法是相等的，那么这两个对象中的每一个对象调用hashCode方法都必须生成相同的整数结果。举例说，在HashSet中，通过被存入对象的hashCode()来确定对象在HashSet中的存储地址，通过equals()来确定存入的对象是否重复，hashCode()和equals()都需要重新定义，因为hashCode()默认是由对象在内存中的存储地址计算返回一个整数得到，而equals()默认是比较对象的引用，如果不同时重写他们的话，那么同一个类产生的两个完全相同的对象就都可以存入Set，因为他们是通过equals()来确定的，这就是HashSet失去了意义。 
Map的思想是查找对象要比线性查找更快，使用hashed keys 来定位需要查找的对象需要两步。Map的内部存贮以二维数组的形式类似的方式存储对象，第一个数组的索引是key的hashcode()之后的值。对第二个层数组的查找是利用equals()进行线性比较来确定对象是否存在。
对象中默认实现的hashcode()对不同的对象返回不同的整数。因此，在上边的例子中，不同的对象（即使是相同的类型）都有不同的hashCode()。
如果，只是重写了equal可能在查找的时候，找不大存储的对象
Maven的工作原理？ 

答：采用远程仓库和本地仓库以及一个类似build.xml的pom.xml，将pom.xml中定义的jar文件从远程仓库下载到本地仓库，哥哥应用使用同一个本地仓库的jar，同一个版本的jar只需要下载一次，而且避免每个应用都去拷贝jar。同时它采用了插件的体系架构，只保留最小号核心，其余功能都通过插件的形式提供。 

iBatis和Hibernate的区别和各自优缺点？
 
答：IBATIS的最大优点是控制SQL发送的数目，提高数据层的访问效率。IBATIS是半自动化的，通过表和对象的映射以及手写的SQL语句，可以实现比Hibernate更高的查询效率。它的优点具体有易于学习和掌握，容易对SQL进行优化，可以进行细粒度的优化。缺点就是不同的数据库支持不好，缺省的cache支持不好。 

Hibernate对JDBC进行了轻量级的封装，使得Java程序员可以使用对象编程的思维来操作数据库。优点是它使用Java反射机制而不是字节码增强程序来实现透明性，它的性能比较好，因为它是个轻量级的框架，映射灵活出色，支持多种关系型数据库，从一对一到多对多的各种复杂关系。缺点是限制你所使用的对象模型，比如一个持久性类不能映射到多个表。 

JDBC

HashMap和HashTable的区别？ 

答：Hashtable是基于陈旧的Dictionary类的，HashMap是Java1.2中引进的Map接口的一个实现。Hashtable是线程安全的，HashMap不是线程安全的。HashMap可以将null作为一个条目的key或者value。 

List，Set和Map的区别？ 

答：List顺序存储，可以存储相同的对象。Set顺序存储不能存储相同的对象。Map中含有将key,value作为一组值作为一条记录来存储，key和value都可以分别作为一个collection取出来。 

谈谈Java的反射机制？
 
答：Java发射机制可以让我们在运行时加载，探知，使用编译期间完全未知的classes。换句话说就是Java程序可以加载一个在运行时才得知名称的class，获悉其完整构造，并生成其对象实体，或对其fields设值，或调用其methods。 

谈谈JVM工作原理？ 

答：操作系统装入jvm是通过jdk中的java.exe来完成的，通常有下面四个步骤。1.创建jvm装载环境和配置。2.装载jvm.dll。3.初始化jvm.dll并挂接到JNIENV(JNI调用接口)实例。4.调用JNIENV实例装载并处理class类。 

谈谈ClassLoader的工作原理？ 

答：ClassLoader是用来Class文件到JVM的。ClassLoader在JVM运行的时候加载java核心API以满足java程序最基本的需要，其中就包括用户定义的ClassLoader，这里所谓的用户定义是只通过java程序实现的ClassLoader，一个是ExtClassLoader，这个ClassLoader是用来加载java的扩展API的，也就是/lib/ext中的类。一个是AppClassLoader，这个ClassLoader是用来加载用户机器上CLASSPATH设置目录中的Class的，通常在没有指定ClassLoader的情况下，程序员自定义的类就由该ClassLoader来进行加载。 
当运行一个程序的时候，JVM启动，运行bootstrap classloader，该ClassLoader加载Java核心API(ExtClassLoader和AppClassLoader也在此时加载)，然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class。这就是一个程序最基本的加载流程。 

Google是怎么做到一提交Query就立马返回结果？ 

答：因为它使用了倒排索引的技术。

说几个J2EE中使用的协议？ 

答：SOAP, JAXP, JAXM, UDDI 

如何在Oracle中实现分页查询？
 
答：select * from (select rownum as rowno, T.* from k_task T where … and rownum <= 20) table_alias where table_alias.rowno >= 10; 如果要排序的话把排序子句放到内层查询。 

Web Application是通过什么来启动Servlet的？ 

答：Servlet由Web服务器加载启动。 

举例几个Apache上的开源项目？ 

答：iBatis，Maven，Velocity，POI，Ant, Apache HTTP Server. 

Object类有哪些方法？ 

答：equals(), hashCode(), getClass(), toString(), notify(), notifyAll(), wait(), clone() 

equals()和==的区别？

基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean 他们之间的比较，应用双等号（==）,比较的是他们的值。 
复合数据类型(类) 当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 

JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。

Servlet的生命周期： 
    
servlet有良好的生存期的定义，包括如何加载、实例化、初始化、处理客户端请求以及如何被移除。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。 

1、加载和实例化 

　　容器负责加载和实例化一个servlet。实例化和加载可以发生在引擎启动的时候，也可以推迟到容器需要该servlet为客户请求服务的时候。 

　　首先容器必须先定位servlet类，在必要的情况下，容器使用通常的Java类加载工具加载该servlet，可能是从本机文件系统，也可以是从远程文件系统甚至其它的网络服务。容器加载servlet类以后，它会实例化该类的一个实例。需要注意的是可能会实例化多个实例，例如一个servlet类因为有不同的初始参数而有多个定义，或者servlet实现SingleThreadModel而导致容器为之生成一个实例池。 

　　2、初始化 

　　servlet加载并实例化后，容器必须在它能够处理客户端请求前初始化它。初始化的过程主要是读取永久的配置信息，昂贵资源（例如JDBC连接）以及其它仅仅需要执行一次的任务。通过调用它的init方法并给它传递唯一的一个（每个servlet定义一个）ServletConfig对象完成这个过程。给它传递的这个配置对象允许servlet访问容器的配置信息中的名称－值对（name-value）初始化参数。这个配置对象同时给servlet 提供了访问实现了ServletContext接口的具体对象的方法，该对象描述了servlet的运行环境。 

　　2.1初始化的错误处理 

　　在初始化期间，servlet实例可能通过抛出UnavailableException 或者 ServletException异常表明它不能进行有效服务。如果一个servlet抛出一个这样的异常，它将不会被置入有效服务并且应该被容器立即释放。在此情况下destroy方法不会被调用因为初始化没有成功完成。在失败的实例被释放后，容器可能在任何时候实例化一个新的实例，对这个规则的唯一例外是如果失败的servlet抛出的异常是UnavailableException并且该异常指出了最小的无效时间，那么容器就会至少等待该时间指明的时限才会重新试图创建一个新的实例。 

　　2.2、工具因素 

　　当工具（注：根据笔者的理解，这个工具可能是应用服务器的某些检查工具，通常是验证应用的合法性和完整性）加载和内省（introspect）一个web应用时，它可能加载和内省该应用中的类，这个行为将触发那些类的静态初始方法被执行，因此，开发者不能假定只要当servlet的init方法被调用后它才处于活动容器运行状态（active container runtime）。作为一个例子，这意味着servlet不能在它的静态（类）初始化方法被调用时试图建立数据库连接或者连接EJB容器。 

　　3、处理请求 

　　在servlet被适当地初始化后，容器就可以使用它去处理请求了。每一个请求由ServletRequest类型的对象代表，而servlet使用 ServletResponse回应该请求。这些对象被作为service方法的参数传递给servlet。在HTTP请求的情况下，容器必须提供代表请求和回应的HttpServletRequest和HttpServletResponse的具体实现。需要注意的是容器可能会创建一个servlet实例并将之放入等待服务的状态，但是这个实例在它的生存期中可能根本没有处理过任何请求。 

　　3.1、多线程问题 

　　容器可能同时将多个客户端的请求发送给一个实例的service方法，这也就意味着开发者必须确保编写的servlet可以处理并发问题。如果开发者想防止这种缺省的行为，那么他可以让他编写的servlet实现SingleThreadModel。实现这个类可以保证一次只会有一个线程在执行service 方法并且一次性执行完。容器可以通过将请求排队或者维护一个servlet实例池满足这一点。如果servlet是分布式应用的一部分，那么，那么容器可能在该应用分布的每个JVM中都维护一个实例池。如果开发者使用synchronized关键字定义service方法(或者是doGet和 doPost)，容器将排队处理请求，这是由底层的java运行时系统要求的。我们强烈推荐开发者不要同步service方法或者HTTPServlet 的诸如doGet和doPost这样的服务方法。 

　　3.2、处理请求中的异常 

　　servlet在对请求进行服务的时候有可能抛出ServletException或者UnavailableException异常。ServletException表明在处理请求的过程中发生了错误容器应该使用合适的方法清除该请求。UnavailableException表明servlet不能对请求进行处理，可能是暂时的，也可能是永久的。如果UnavailableException指明是永久性的，那么容器必须将servlet从服务中移除，调用它的destroy方法并释放它的实例。如果指明是暂时的，那么容器可以选择在异常信息里面指明的这个暂时无法服务的时间段里面不向它发送任何请求。在这个时间段里面被被拒绝的请求必须使用SERVICE_UNAVAILABLE (503)返回状态进行响应并且应该携带稍后重试（Retry-After）的响应头表明不能服务只是暂时的。容器也可以选择不对暂时性和永久性的不可用进行区分而全部当作永久性的并移除抛出异常的servlet。 

　　3.3线程安全 

　　开发者应该注意容器实现的请求和响应对象（注：即容器实现的HttpServletRequest和HttpServletResponese）没有被保证是线程安全的，这就意味着他们只能在请求处理线程的范围内被使用，这些对象不能被其它执行线程所引用，因为引用的行为是不确定的。 

　　4、服务结束 

　　容器没有被要求将一个加载的servlet保存多长时间，因此一个servlet实例可能只在容器中存活了几毫秒，当然也可能是其它更长的任意时间（但是肯定会短于容器的生存期）当容器决定将之移除时（原因可能是保存内存资源或者自己被关闭），那么它必须允许servlet释放它正在使用的任何资源并保存任何永久状态（这个过程通过调用destroy方法达到）。容器在能够调用destroy方法前，它必须允许那些正在service方法中执行的线程执行完或者在服务器定义的一段时间内执行（这个时间段在容器调用destroy之前）。一旦destroy方法被调用，容器就不会再向该实例发送任何请求。如果容器需要再使用该servlet，它必须创建新的实例。destroy方法完成后，容器必须释放servlet实例以便它能够被垃圾回收。 


Java中Error与Exception的区别： 

Exceptions 

1．可以是 可被控制(checked) 或 不可控制的(unchecked) 

2．表示一个由程序员导致的错误 

3．应该在应用程序级被处理 

Errors 

1．总是 不可控制的(unchecked) 

2．经常用来用于表示系统错误或低层资源的错误 

3．如何可能的话，应该在系统级被捕捉 

error   表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。  

Java的序列化接口的作用： 

Serializable接口，是作为一个标记使用的，因为本身没有任何方法需要实现； 
Java内部的序列化机制会检查此接口，如果有这个接口，则序列化它，否则不序列化。 
典型的用途是在分布式Java编程里，比如通过RMI或者EJB，需要在网络上传输的对象，一定要实现此接口，否则程序会出错，因为在网络上传递对象需要先序列化它。 

使用序列化的目的有一个两个:一个是为了persistent对象,如在Hibernate中要保存的对象必须是序列化的;第二个是为了跨平台传输,消除平台间的差异,如在JMS中,传送的消息对象都必须是序列化的. 

Hibernate的三种状态以及表现形式： 



objects在hibernate中的生命周期中存在3种状态:transient, persistent, detached。附件1描述的即是hibernate application中objects的生命周期。 

通过new操作符生成的object是transient object，此时的object还没有和数据库中的任何数据关联，所以一旦没有被引用，就会被jvm垃圾收集。一旦通过Hibernate 的Persistence manager执行了save()方法或者被其他已经存在的Persistent objects引用，那么object的状态就会从transient转为persistent。 

Persistent objects是包含在transactions中的，它们的状态是通过transactions来控制的，  Persistent objects是和数据库中的表对应的，所以表示主键的属性不会为空，也就是说每一个persistent object都会有一个匹配的database identity，除非是通过new产生的新的transient object,此时object的database identity是空的，如果在transaction中对该object执行save()方法，那么在transaction成功结束的时候该 object会在数据库中新增一条对应的记录，其它已经存在的persistent objects会相应的更新数据库中的相应行。 

当Hibernate中的Persistence Manager执行close()方法，也就是persistence Manager放弃对persistent objects的控制，那么persistent objects的状态就转为detached objects。这些detached objects可以在未来被新的persistence manager重新控制并使用。这种将object从transaction转向表现层然后又重新包含于新的Transaction的实现是 Hibernate的一个卖点。 

在objects存在的三种状态中，处于persistent状态中object的比较是通过该object的database identity来确定的，所以这里需要override equals()来实现。其它状态中的objects就可以简单的通过java的equality来判断即可。