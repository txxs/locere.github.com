---
layout: article
title: "Servlet读后整理"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: 4002502.jpg
  thumb:
date: 2016-04-02T09:51:29+08:00
---

{% include toc.html %}

{% highlight java %}

{% endhighlight %}

# 第一章 简介

##  I/O与CPU时间的比较 

这些事情当然很重要，乐趣也不少，但是代码优化所带来的回报，可能轻易就被低效的 I/O 所抵销。I/O 操作比在内存中进行数据处理任务所需时间更长，差别要以数量级计。

正如您所看到的，影响应用程序执行效率的限定性因素，往往并非处理速率，而是 I/O。程序员热衷于调试代码，I/O 性能的调试往往被摆在第二位，甚至完全忽略。殊不知，在 I/O 性能上的小小投入就可换
来可观的回报，想来实在令人惋惜。 

## CPU已不再是束缚

JVM 已然前进了一大步。现在 JVM 运行字节码的速率已经接近本地编译代码，借助动态运行时优化，其表现甚至还有所超越。这就意味着，多数 Java 应用程序已不再受 CPU 的束缚（把大量时间用在执行代码上），而更多时候是受 I/O 的束缚（等待数据传输）。

在大多数情况下，Java 应用程序并非真的受着 I/O 的束缚。操作系统并非不能快速传送数据，让 Java 有事可做；相反，是 JVM 自身在 I/O 方面效率欠佳。操作系统与 Java 基于流的 I/O模型有些不匹配。操作系统要移动的是大块数据（缓冲区），这往往是在硬件直接存储器存取（DMA）的协助下完成的。而 JVM 的 I/O 类喜欢操作小块数据——单个字节、几行文本。结果，操作系统送来整缓冲区的数据，java.io 的流数据类再花大量时间把它们拆成小块，往往拷贝一个小块就要往返于几层对象。操作系统喜欢整卡车地运来数据，java.io 类则喜欢一铲子一铲子地加工数据。有了 NIO，就可以轻松地把一卡车数据备份到您能直接使用的地方（ByteBuffer 对象）。 

## 进入正题

当今的操作系统是现代软件工程的奇迹（没错，有的比奇迹还奇迹），可是 Java 程序员如何能够既利用操作系统的强大功能，又保持平台独立性？唉，天下没有免费的午餐，此为一例。 

如果您是程序员，可以使用 Java 本地接口（JNI）编写本地代码，直接使用操作系统特性。这样的话，您就被绑定在该操作系统上（也许还是其特定版本上）。如果您的本地代码不是 100%无漏洞，您还可能把 JVM 置于频繁出错乃至崩溃的境地。如果您是操作系统开发商，则可以在您的 JVM 实现中包含本地代码，以 Java API 的形式提供这些特性。但这样做可能违反您所签署相关许可协议，根据协议，您只能提供符合一致性要求的 JVM。Sun 曾就此问题将 Microsoft 告上法庭，因为很明显，JDirect 软件包只能在微软的系统上运行。如果以上方法都行不通，那么您只好转向其他语言，以实现对性能要求极为苛刻的应用。 

为了解决这一问题，java.nio 软件包提供了新的抽象。具体地说，就是 Channel 和 Selector类。它们提供了使用 I/O 服务的通用 API，JDK 1.4 以前的版本是无法使用这些服务的。天下还是没有免费的午餐：您无法使用每一种操作系统的每一种特性，但是这些新类还是提供了强大的新框架，涵盖了当今商业操作系统普遍提供的高效 I/O 特性。不仅如此，java.nio.channels.spi还提供了新的服务提供接口（SPI），允许接入新型通道和选择器，同时又不违反规范的一致性。 

## I/O概念 

JDK 1.4 的 NIO 软件包引入了一套新的抽象用于 I/O 处理。与以往不同的是，新的抽象把重点放在了如何缩短抽象与现实之间的距离上面。NIO 抽象与现实中存在的实体有着非常真实直接的交互关系。要想最大限度地满足 Java 应用程序的密集 I/O 需求，理解这些新的抽象，以及与其发生交互作用的 I/O 服务（其重要性并不亚于抽象），正是关键所在。 

### 缓冲区操作

缓冲区，以及缓冲区如何工作，是所有 I/O 的基础。所谓“输入／输出”讲的无非就是把数据移进或移出缓冲区。 

进程执行 I/O 操作，归结起来，也就是向操作系统发出请求，让它要么把缓冲区里的数据排干（写），要么用数据把缓冲区填满（读）。进程使用这一机制处理所有数据进出操作。操作系统内部处理这一任务的机制，其复杂程度可能超乎想像，但就概念而言，却非常直白易懂。 

简单描述数据从外部磁盘向运行中的进程的内存区域移动的过程。进程使用 read( )系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过 DMA 完成，无需主 CPU 协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行read( )调用时指定的缓冲区。

原书中有更多细节。

### 虚拟内存

虚拟内存意为使用虚假（或虚拟）地址取代物理（硬件RAM）内存地址。这样做好处颇多，总结起来可分为两大类： 

1. 一个以上的虚拟地址可指向同一个物理内存地址。 
2. 虚拟内存空间可大于实际可用的硬件内存。 

设备控制器不能通过 DMA 直接存储到用户空间，但通过利用上面提到的第一项，则可以达到相同效果。把内核空间地址与用户空间的虚拟地址映射到同一个物理地址，这样，DMA 硬件（只能访问物理内存地址）就可以填充对内核与用户空间进程同时可见的缓冲区

###  内存页面调度

为了支持虚拟内存的第二个特性（寻址空间大于物理内存），就必须进行虚拟内存分页（经常称为交换，虽然真正的交换是在进程层面完成，而非页层面）。依照该方案，虚拟内存空间的页面能够继续存在于外部磁盘存储，这样就为物理内存中的其他虚拟页面腾出了空间。从本质上说，物理内存充当了分页区的高速缓存；而所谓分页区，即从物理内存置换出来，转而存储于磁盘上的内存页面。 

### 文件I/O

文件 I/O 属文件系统范畴，文件系统与磁盘迥然不同。磁盘把数据存在扇区上，通常一个扇区512 字节。磁盘属硬件设备，对何谓文件一无所知，它只是提供了一系列数据存取窗口。在这点上，磁盘扇区与内存页颇有相似之处：都是统一大小，都可作为大的数组被访问。 

文件系统是更高层次的抽象，是安排、解释磁盘（或其他随机存取块设备）数据的一种独特方式。您所写代码几乎无一例外地要与文件系统打交道，而不是直接与磁盘打交道。是文件系统定义了文件名、路径、文件、文件属性等抽象概念。 

所有 I/O 都是通过请求页面调度完成的。您应该还记得，页面调度是非常底层的操作，仅发生于磁盘扇区与内存页之间的直接传输。而文件 I/O 则可以任意大小、任意定位。那么，底层的页面调度是如何转换为文件I/O 的？ 文件系统把一连串大小一致的数据块组织到一起。有些块存储元信息，如空闲块、目录、索引等的映射，有些包含文件数据。单个文件的元信息描述了哪些块包含文件数据、数据在哪里结束、最后一次更新是什么时候，等等。 

























