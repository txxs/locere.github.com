---
layout: article
title: "Java多线程、网络基本问题、基础"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: Translate.jpg
  thumb:
date: 2016-03-14T13:50:29+08:00
---

{% include toc.html %}

{% highlight java %}

{% endhighlight %}

## 面试java基础总结大全#多线程（牛客）

### 进程和线程

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2) 线程的划分尺度小于进程，使得多线程程序的并发性高。

3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

6) 线程太多会导致效率的降低，因为线程的执行依靠的是CPU的来回切换。

### jvm多线程的启动是多线程吗？
    
java的虚拟机jvm启动的是单线程，就有发生内存泄露的可能，而我们使用java程序没出现这样的问题，也就是jvm启动至少有两个线程，一个执行java程序，一个执行垃圾回收。所以是多线程。

### 实现多线程的方法

实现多线程可以通过继承Thread类和实现Runnable接口。

(1)继承Thread,定义一个类继承Thread类,复写Thread类中的public void run()方法，将线程的任务代码封装到run方法中,直接创建Thread的子类对象，创建线程，调用start()方法，开启线程(调用线程的任务run方法)

(2)实现Runnable接口；定义一个类，实现Runnable接口；覆盖接口的public void run()的方法，将线程的任务代码封装到run方法中；，创建Runnable接口的子类对象，将Runnabl接口的子类对象作为参数传递给Thread类的构造函数，创建Thread类对象，调用start()方法，启动线程。

（原因：线程的任务都封装在Runnable接口子类对象的run方法中。所以要在线程对象创建时就必须明确要运行的任务）。

两种方法区别：

(1)实现Runnable接口避免了单继承的局限性

(2)继承Thread类线程代码存放在Thread子类的run方法中；实现Runnable接口线程代码存放在接口的子类的run方法中；


### 创建线程是为什么要复写run方法？

Thread类用于描述线程。Thread类定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。

### start()和run方法有什么区别？

调用start方法方可启动线程，而run方法只是thread的一个普通方法，调用run方法不能实现多线程；

Start()方法:
start方法用来启动线程,实现了多线程运行,这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程,这时此线程处于就绪(可运行)状态，并没有运行，一旦得到cpu时间片(执行权),就开始执行run()方法,这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束,此线程随即终止。


Run()方法:
run()方法只是Thread类的一个普通方法,如果直接调用Run方法,程序中依然只有主线程这一个线程,其程序执行路径还是只有一条，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。

### 线程的几种状态：

新建：new一个Thread对象或者其子类对象就是创建一个线程，当一个线程对象被创建，但是没有开启，这个时候，只是对象线程对象开辟了内存空间和初始化数据。    

    
就绪：新建的对象调用start方法，就开启了线程，线程就到了就绪状态。在这个状态的线程对象，具有执行资格，没有执行权。

运行：当线程对象获取到了CPU的资源。在这个状态的线程对象，既有执行资格，也有执行权。

冻结：运行过程中的线程由于某些原因(比如wait,sleep)，释放了执行资格和执行权。当然，他们可以回到运行状态。只不过，不是直接回到。而是先回到就绪状态。

死亡：当线程对象调用的run方法结束，或者直接调用stop方法，就让线程对象死亡，在内存中变成了垃圾。      

### sleep()和wait()的区别：

(1)这两个方法来自不同的类，sleep()来自Thread类，和wait()来自Object类。

(2)sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。而wait()是Object类的非静态方法

(3)sleep()释放资源不释放锁，而wait()释放资源释放锁；

(4)使用范围：wait,notify和notifyAll只能在同步控制方法或者同步控制块里面使用,而sleep可以在任何地方使用

### 什么是锁?锁的作用是什么?

锁就是对象。锁的作用是保证线程同步，解决线程安全问题。持有锁的线程可以在同步中执行，没有锁的线程即使获得cpu执行权，也进不去。

### 同步的前提:
(1)必须保证有两个以上线程

(2)必须是多个线程使用同一个锁，即多条语句在操作线程共享数据

(3)必须保证同步中只有一个线程在运行

好处：同步解决了多线程的安全问题

弊端：多线程都需要判断锁，比较消耗资源

### 同步的两种表现形式：

(1)同步代码块:可以指定需要获取哪个对象的同步锁,使用synchronized的代码块同样需要锁,但他的锁可以是任意对象考虑到安全问题，一般还是使用同一个对象，相对来说效率较高。

注意：

**虽然同步代码快的锁可以使任何对象，但是在进行多线程通信使用同步代码快时，必须保证同步代码快的锁的对象和，否则会报错。

**同步函数的锁是this，也要保证同步函数的锁的对象和调用wait、notify和notifyAll的对象是同一个对象，也就是都是this锁代表的对象。

格式：
synchronized(对象)
{
需同步的代码;
}

(2)同步函数
同步方法是指进入该方法时需要获取this对象的同步锁，在方法上使用synchronized关键字，使用this对象作为锁，也就是使用了当前对象，因为锁住了方法，所以相对于代码块来说效率相对较低。

注:静态同步函数的锁是该方法所在的类的字节码文件对象，即类名.class文件
格式：

修饰词 synchronized 返回值类型 函数名(参数列表)
{
需同步的代码;
}

在jdk1.5后，用lock锁取代了synchronized，个人理解也就是对同步代码块做了修改，
并没有提供对同步方法的修改，主要还是效率问题吧。

### 多线程的单例设计模式：保证某个类中内存中只有一个对象

(1)饿汉式:


{% highlight java %}

		class Single
		{
			private Single(){}//将构造函数私有化，不让别的类建立该类对象
			private static final Single s=new Single();//自己建立一个对象
			public static Single getInstance()//提供一个公共访问方式
			{
				return s;
			}
		}
		
{% endhighlight %}
(2)懒汉式：
{% highlight java %}
		class Single
		{
			private Single(){} 
			private static Single s;
			public static Single getInstance()
			{
				if(s==null)
					s=new Single();
				return s;
			}
		}
		
{% endhighlight %}
饿汉式和懒汉式的区别：
**
饿汉式是类一加载进内存就创建好了对象；
懒汉式则是类加载进内存的时候，对象还没有存在，只有调用了getInstance()方法时，对象才开始创建。
**

懒汉式是延迟加载，如果多个线程同时操作懒汉式时就有可能出现线程安全问题，解决线程安全问题，可以加同步来解决。但是加了同步之后，每一次都要比较锁，效率就变慢了，
所以可以加双重判断来提高程序效率。如将上述懒汉式的Instance函数改成同步：
{% highlight java %}
		public static Single getInstance()
		{
			if(s==null)
			{
				synchronized(Single.class)
				{
					if(s==null) 
						s=new Single();
				}
			}
			return s;
		}
{% endhighlight %}

###　死锁

两个线程对两个同步对象具有循环依赖时，就会发生死锁。即同步嵌套同步，而锁却不同。

### wait()、sleep()、notify()、notifyAll()

wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 

sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 

notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程(一般是最先开始等待的线程)，而且不是按优先级。 

Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

### 为什么wait()、notify()、notifyAll()这些用来操作线程的方法定义在Object类中？

(1)这些方法只存在于同步中；

(2)使用这些方法时必须要指定所属的锁，即被哪个锁调用这些方法；

(3)而锁可以是任意对象，所以任意对象调用的方法就定义在Object中。

### Lock和Condition
实现提供比synchronized方法和语句可获得的更广泛的锁的操作，可支持多个相关的Condition对象

Lock是个接口
锁是控制多个线程对共享数据进行访问的工具。

JDK1.5中提供了多线程升级的解决方案：

将同步synchonized替换成了显示的Lock操作，将Object中的wait、notify、notifyAll替换成了Condition对象。

该对象可以Lock锁进行获取

Lock的方法摘要：

void lock()  获取锁。 

Condition newCondition() 返回绑定到此 Lock 实例的新 Condition 实例。
 
void unlock() 释放锁。

Condition方法摘要：

void await() 造成当前线程在接到信号或被中断之前一直处于等待状态。

void signal() 唤醒一个等待线程。          

void signalAll() 唤醒所有等待线程。

### 守护线程(后台线程)

setDaemon(boolean on):将该线程标记为守护线程或者用户线程。
当主线程结束，守护线程自动结束，比如圣斗士星矢里面的守护雅典娜，在多线程里面主线程就是雅典娜，守护线程就是圣斗士，主线程结束了，守护线程则自动结束。

当正在运行的线程都是守护线程时，java虚拟机jvm退出；所以该方法必须在启动线程前调用；

守护线程的特点：

守护线程开启后和前台线程共同抢夺cpu的执行权，开启、运行两者都没区别，
但结束时有区别，当所有前台线程都结束后，守护线程会自动结束。

### 多线程join方法：

void join() 等待该线程终止。
void join(long millis)  等待该线程终止的时间最长为 millis 毫秒。
throws InterruptedException       
  
特点：当A线程执行到B线程的join方法时，A就会等待B线程都执行完，A才会执行

作用: join可以用来临时加入线程执行；

### 多线程优先级：yield()方法
yield():暂停当前正在执行的线程对象，并执行其他线

setPriority(int newPriority):更改线程优先级

int getPriority() 返回线程的优先级。

String toString() 返回该线程的字符串表示形式，包括线程名称、优先级和线程组
           
(1)MAX_PRIORITY:最高优先级(10级)

(1)Min_PRIORITY:最低优先级(1级)

(1)Morm_PRIORITY:默认优先级(5级)

###　 什么是ThreadLocal类,怎么使用它？

ThreadLocal类提供了线程局部 (thread-local) 变量。是一个线程级别的局部变量，并非“本地线程”。

ThreadLocal 为每个使用该变量的线程,提供了一个独立的变量副本，每个线程修改副本时不影响其它线程对象的副本

下面是线程局部变量(ThreadLocal variables)的关键点：

一个线程局部变量(ThreadLocal variables)为每个线程方便地提供了一个单独的变量。

ThreadLocal 实例通常作为静态的私有的(private static)字段出现在一个类中，这个类用来关联一个线程。 

当多个线程访问 ThreadLocal 实例时，每个线程维护 ThreadLocal 提供的独立的变量副本。

常用的使用可在 DAO 模式中见到，当 DAO 类作为一个单例类时，
数据库链接(connection)被每一个线程独立的维护，互不影响。(基于线程的单例)


### 在静态方法上使用同步时会发生什么事？

同步静态方法时会获取该类的“Class”对象，所以当一个线程进入同步的静态方法中时，线程监视器获取类本身的对象锁，其它线程不能进入这个类的任何静态同步方法。

它不像实例方法，因为多个线程可以同时访问不同实例同步实例方法。

###面向对象主要有四大特性：

封装、抽象、继承和多态。

封装：在面向对象语言中，封装特性是由类来体现的，我们将现实生活中的一类实体定义成类，其中包括属性和行为（在Java中就是方法），就好像人类，可以具有name,sex,age等属性，同时也具有eat(),sleep()等行为，我们在行为中实现一定的功能，也可操作属性，这是面向对象的封装特性；

抽象：抽象就是将一类实体的共同特性抽象出来，封装在一个抽象类中，所以抽象在面向对象语言是由抽象类来体现的。比如鸟就是一个抽象实体，因为抽象实体并不是一个真正的对象，它的属性还不能完全描述一个对象，所以在语言中体现为抽象类不能实例化；

继承：继承就像是我们现实生活中的父子关系，儿子可以遗传父亲的一些特性，在面向对象语言中，就是一个类可以继承另一个类的一些特性，从而可以代码重用，其实继承体现的是is-a关系，父类同子类在本质上还是一类实体；

多态：多态就是通过传递给父类对象引用不同的子类对象从而表现出不同的行为 ...

### 多线程有什么用？

一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：

（1）发挥多核CPU的优势

随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。

（2）防止阻塞

从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。

（3）便于建模

这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。

### Runnable接口和Callable接口的区别

有点深的问题了，也看出一个Java程序员学习知识的广度。

Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。

这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。

### volatile关键字的作用

一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：

（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据

（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–>字节码–>根据字节码执行对应的C/C++代码–>C/C++代码被编译成汇编语言–>和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率

从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。

### 什么是线程安全

又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

这个问题有值得一提的地方，就是线程安全也是有几个级别的：

（1）不可变

像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用

（2）绝对线程安全

不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet

（3）相对线程安全

相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。

（4）线程非安全

这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类

### Java中如何获取到线程dump文件

死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：

（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java

（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid

另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，

### 如何在两个线程之间共享数据

通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的

### 为什么要使用线程池

避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。

### 怎么检测一个线程是否持有对象监视器

我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程

### synchronized和ReentrantLock的区别

synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：

（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁

（2）ReentrantLock可以获取各种锁的信息

（3）ReentrantLock可以灵活地实现多路通知

另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。

### ConcurrentHashMap的并发度是什么

ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？

### FutureTask是什么

这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。

### Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？

这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？

关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：

（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性

（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。

### 线程类的构造方法、静态块是被哪个线程调用的

这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。

如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：

（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的

（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的

### 同步方法和同步块，哪个是更好的选择

同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。

借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁->解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–>解锁的次数，有效地提升了代码执行的效率。

### 高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？

这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：

（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换

（2）并发不高、任务执行时间长的业务要区分开看：

a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务

b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换

（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。

我不能保证写的每个地方都是对的，但是至少能保证不复制、不黏贴，保证每一句话、每一行代码都经过了认真的推敲、仔细的斟酌。每一篇文章的背后，希望都能看到自己对于技术、对于生活的态度。

我相信乔布斯说的，只有那些疯狂到认为自己可以改变世界的人才能真正地改变世界。面对压力，我可以挑灯夜战、不眠不休；面对困难，我愿意迎难而上、永不退缩。

### Semaphore有什么作用

Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。

### 单例模式的线程安全性

老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：

（1）饿汉式单例模式的写法：线程安全

（2）懒汉式单例模式的写法：非线程安全

（3）双检锁单例模式的写法：线程安全

### 什么是AQS

简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。

如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。

AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。

### 什么是乐观锁和悲观锁

（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。

（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

### 什么是CAS

CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。

### 什么是Java内存模型

Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：

（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去

（2）定义了几个原子操作，用于操作主内存和工作内存中的变量

（3）定义了volatile变量的使用规则

（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的

### 什么是自旋

很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。

### Thread.sleep(0)的作用是什么

这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。

### Java中用到的线程调度算法是什么

抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

### 如果你提交任务时，线程池队列已满，这时会发生什么

如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。

### 什么是多线程的上下文切换

多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。

### 不可变对象对多线程有什么帮助

前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。

### 怎么唤醒一个阻塞的线程

如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。

### Java编程写一个会导致死锁的程序

第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。

真正理解什么是死锁，这个问题其实不难，几个步骤：

（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；

（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁

（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的

这样，线程1″睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。






##  面试java基础总结大全#网络编程

### 网络编程概述

(1)网络模型

OSI参考模型
TCP/IP参考模型

(2)网络通讯要素
IP地址
端口号
传输协议

(3)网络通讯前提：
**找到对方IP
**数据要发送到指定端口。为了标示不同的应用程序，所以给这些网络应用程序都用数字进行标示
 。这个表示就叫端口。
**定义通信规则。这个规则称为通信协议，国际组织定义了通用协议TCP/IP

(4)计算机网络：
是指将地理位置不同的具有独立功能的多台计算机及其外部设备，
通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，
实现资源共享和信息传递的计算机系统。

(5)IP地址：
IP地址 = 网络号码+主机地址
A类IP地址:第一段号码为网络号码，剩下的三段号码为本地计算机的号码
B类IP地址:前二段号码为网络号码，剩下的二段号码为本地计算机的号码
C类IP地址:前三段号码为网络号码，剩下的一段号码为本地计算机的号码
特殊地址:
127.0.0.1 回环地址,可用于测试本机的网络是否有问题. ping 127.0.0.1   
ipconfig:查看本机IP地址
xxx.xxx.xxx.0 网络地址
xxx.xxx.xxx.255 广播地址

A类1.0.0.1---127.255.255.25410.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)(2)127.X.X.X是保留地址，用做循环测试用的。
B类128.0.0.1---191.255.255.254172.16.0.0---172.31.255.255是私有地址。169.254.X.X是保留地址。
C类192.0.0.1---223.255.255.254192.168.X.X是私有地址
D类224.0.0.1---239.255.255.254
E类240.0.0.1---247.255.255.254

(6)各种网络分类方式
A:按网络覆盖范围划分
局域网(几米至10公里以内) 　　城域网(10~100公里) 　　广域网(几百公里到几千公里) 　　国际互联网
B:按网络拓扑结构划分
总线型网络 　　星形网络 　　环型网络 　　树状网络 　　混合型网络
C:按传输介质划分
有线网 　　无线网
D:按网络使用性质划分
公用网 　　专用网


(7)虚拟专用网络（Virtual Private Network ，简称VPN)指的是在公用网络上建立专用网络的技术。
其之所以称为虚拟网，主要是因为整个VPN网络的任意两个节点之间的连接并没有传统专网
所需的端到端的物理链路，而是架构在公用网络服务商所提供的网络平台，如Internet、
ATM(异步传输模式〉、Frame Relay （帧中继）等之上的逻辑网络，
用户数据在逻辑链路中传输。它涵盖了跨共享网络或公共网络的封装、
加密和身份验证链接的专用网络的扩展。VPN主要采用了隧道技术、加解密技术、
密钥管理技术和使用者与设备身份认证技术。


(8)网络模型：
****OSI模型
应用层
表示层
会话层
传输层
网络层
数据连接层
物理层
****TCP/IP模型
应用层
传输层
网际层
主机至网络层

### TCP和UDP
(1)UDP和TCP的区别：

UDP
将数据及源和目的封装成数据包中，不需要建立连接
每个数据报的大小在限制在64k内
因无连接，是不可靠协议
不需要建立连接，速度快

TCP
建立连接，形成传输数据的通道。
在连接中进行大数据量传输
通过三次握手完成连接，是可靠协议
必须建立连接，效率会稍低

注：三次握手：
第一次：我问你在么？
第二次：你回答在。
第三次：我反馈哦我知道你在。

### Socket(UDP传输)

**Socket就是为网络服务提供的一种机制。

**通信的两端都有Socket。

**网络通信其实就是Socket间的通信。

**数据在两个Socket间通过IO传输。

**玩Socket主要就是记住流程，代码查文档就行


(1)UDP传输：DatagramSocket与DatagramPacket

**发送端：
建立DatagramSocket服务；
提供数据，并将数据封装到字节数组中；
创建DatagramPacket数据包，并把数据封装到包中，同时指定IP和接收端口
通过Socket服务，利用send方法将数据包发送出去；
关闭DatagramSocket和DatagramPacket服务。

**接收端：
建立DatagramSocket服务，并监听一个端口；
定义一个字节数组和一个数据包，同时将数组封装进数据包；
通过DatagramPacket的receive方法，将接收的数据存入定义好的数据包；

通过DatagramPacke关闭t的方法，获取发送数据包中的信息；
关闭DatagramSocket和DatagramPacket服务。
DatagramSocket与DatagramPacket方法摘要：
*****DatagramSocket

构造方法：
DatagramSocket() 
构造数据报套接字并将其绑定到本地主机上任何可用的端口。
DatagramSocket(int port) 
创建数据报套接字并将其绑定到本地主机上的指定端口。 
DatagramSocket(int port, InetAddress laddr) 
创建数据报套接字，将其绑定到指定的本地地址。 
方法摘要:
void close() 
关闭此数据报套接字。
InetAddress getInetAddress() 
返回此套接字连接的地址。 
InetAddress getLocalAddress() 
获取套接字绑定的本地地址。
int getPort() 
返回此套接字的端口。 
void receive(DatagramPacket p) 
从此套接字接收数据报包。 
void send(DatagramPacket p) 
从此套接字发送数据报包。
****DatagramPacket
构造方法：
DatagramPacket(byte[] buf, int length) 
构造 DatagramPacket，用来接收长度为 length 的数据包。
DatagramPacket(byte[] buf, int length, InetAddress address, int port) 
构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。
InetAddress getAddress() 
返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。 
byte[] getData() 
返回数据缓冲区。 
int getLength() 
返回将要发送或接收到的数据的长度。
int getPort() 
返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。

(2)TCP传输
Socket和ServerSocket
建立客户端和服务器端
建立连接后，通过Socket中的IO流进行数据的传输
关闭socket
同样，客户端与服务器端是两个独立的应用程序。
****Socket
**构造方法：
Socket() 
通过系统默认类型的 SocketImpl 创建未连接套接字
Socket(InetAddress address, int port) 
创建一个流套接字并将其连接到指定 IP 地址的指定端口号。
Socket(String host, int port) 
创建一个流套接字并将其连接到指定主机上的指定端口号。
**方法摘要：
void close() 
关闭此套接字。
InetAddress getInetAddress() 
返回套接字连接的地址。
InputStream getInputStream() 
返回此套接字的输入流。
OutputStream getOutputStream() 
返回此套接字的输出流。 
int getPort() 
返回此套接字连接到的远程端口。
void shutdownInput() 
此套接字的输入流置于“流的末尾”。 
void shutdownOutput() 
禁用此套接字的输出流。 
String toString() 
将此套接字转换为 String。
****ServerSocket
**构造方法：
ServerSocket() 
创建非绑定服务器套接字。 
ServerSocket(int port) 
创建绑定到特定端口的服务器套接字。
方法摘要：
Socket accept() 
侦听并接受到此套接字的连接。
void close() 
关闭此套接字。 
InetAddress getInetAddress() 
返回此服务器套接字的本地地址。
****TCP传输流程：
**客户端：
建立Socket服务，并制定要连接的主机和端口；
获取Socket流中的输出流OutputStream，将数据写入流中，通过网络发送给服务端；
获取Socket流中的输出流InputStream，获取服务端的反馈信息；
关闭资源。
**服务端：
建立ServerSocket服务，并监听一个端口；
通过ServerSocket服务的accept方法，获取Socket服务对象；
使用客户端对象的读取流获取客户端发送过来的数据；
通过客户端对象的写入流反馈信息给客户端；
关闭资源；

## 面试java基础总结大全#面向对象

### 成员变量和局部变量的区别(重点)

(1)作用域
成员变量：针对整个类有效。
局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)

(2)存储位置
成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。
局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。
 当方法调用完，或者语句结束后，就自动释放。

(3)初始值
成员变量：有默认初始值。
局部变量：没有默认初始值，使用前必须赋值。

### 封装：
指隐藏对象的属性和实现细节，仅对外提供公共访问方式；比如电脑机箱、笔记本等
好处：
将变化隔离；
方便使用；
提高复用性；
提高安全性

### Person p = new Person();在内存中做了哪些事情。

(1)将Person.class文件加载进内存中。

(2)如果p定义在主方法中，那么，就会在栈空间开辟一个变量空间p。

(3)在堆内存给对象分配空间。

(4)对对象中的成员进行默认初始化。

(5)对对象中的成员进行显示初始化。

(6)调用构造代码块对对象进行初始化。(如果没有就不执行)

(7)调用构造方法对对象进行初始化。对象初始化完毕。

(8)将对象的内存地址赋值给p变量，让p变量指向该对象。

### static关键字：

(1)静态的意思，用来修饰成员变量和成员函数

(2)静态的特点:
随着类的加载而加载
优先于对象存在
对所有对象共享
可以被类名直接调用

(3)静态的注意事项
A:静态方法只能访问静态成员
为什么：因为静态的内容是随着类的加载而加载，它是先进内存的。
B:静态方法中不能使用this,super关键字
C:主方法是静态的
public static void main(String[] args)
public:公共的意思，是最大权限修饰符。
static:由于jvm调用main方法的时候，没有创建对象。
      只能通过类名调用。所以，main必须用static修饰。
void:由于main方法是被jvm调用，不需要返回值。用void修饰。
main:main是主要的意思，所以jvm采用了这个名字。是程序的入口。
String[]:字符串数组
args:数组名
在运行的时候，通过java命令给args数组赋值。
格式：java MainTest hello world itcast

(4)静态变量和成员变量的区别
A：调用方式
静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。
这个变量属于类。
成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。
B：存储位置
静态变量存储在方法区长中的静态区。
成员变量存储在堆内存。
C：生命周期
静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。
成员变量随着对象的创建而存在，随着对象的消失而消失。
D：与对象的相关性
静态变量是所有对象共享的数据。
成员变量是每个对象所特有的数据。

(5)静态的优点和弊端
优点：
对对象的共享数据进行单独空间的存储，节省内存，没有必要每个对象都存储一份
可直接被类名调用
弊端：
生命周期过长，随着类的消失而消失
访问出现权限，即静态虽好但只能访问静态

(6)什么使用使用静态呢？
A:当所有对象共享某个数据的时候，就把这个成员变量定义为静态修饰的。
B:当某个方法没有访问该类中的非静态成员，就可以把这个方法定义为静态修饰。
静态的生命周期比较长，所以一般不推荐使用。

(7)静态代码块
A:它只执行一次，它比main还先执行。
B:执行顺序
静态代码块--构造代码块--构造方法

### 重写和重载的区别？

重载：在同一类中。方法名相同，参数列表不同。重载可以改变返回类型。
重写：在不同类中(子父类中)。
     方法声明相同(返回类型，方法名，参数列表均相同)。


重写需要注意：
**子类方法的访问权限要大于等于父类方法的访问权限。
**静态只能重写静态。但是这种情况一般不会出现。
构造方法
**子类的实例化过程
***子类创建对象时，会先去创建父类的对象。
   默认是去调用父类的无参构造方法。
***子类构造方法中，第一行默认是super()
***为什么子类中第一行会默认有super()
因为他继承父类的成员使用，使用前这些成员必须初始化，
而他们是父类的成员，所以，必须通过父类进行初始化。
所以，会先创建一个父类的对象。
**当父类没有无参构造方法时
必须使用this或者super调用其他的构造方法。

### 接口和抽象类的区别

A：抽象类只能被单继承
  接口可以多实现,接口的出现避免了多继承的局限性。
  
B：抽象类中的数据特点：
成员变量：可以是变量，也可以是常量
成员方法：可以是抽象方法，也可以是非抽象方法
构造方法：有构造方法
  接口中的数据特点：
成员变量：是常量。默认修饰 public static final
成员方法：都是抽象方法。都有默认修饰 public abstract
构造方法：没有构造方法

C：抽象类中定义的是继承体系中的共性功能。
  接口中定义的是继承体系中的扩展功能。
  
D：抽象类被继承是"is a"关系:xx是yy的一种
  接口被实现是"like a"关系:xx像yy的一种

### 多态：
(1)同一个对象，在程序不同时刻的多种运行状态。举例：动物，狗是狗，狗是动物。水(气态，液态，固态)

(2)多态前提
A:存在着继承或者实现关系
B:有方法的重写
C:父类(接口)引用指向子类(实现)对象

(3)多态的好处和弊端：
好处：多态的存在提高了程序的扩展性和后期可维护性
弊端：虽然可以预先使用，但是只能访问父类中已有的功能，运行的是后期子类的功能内容。
     不能预先使用子类中定义的特有功能。

(4)多态中对象调用成员的特点
Fu f = new Zi();
A:成员变量
编译看左边，运行看左边
B:成员方法 
编译看左边，运行看右边
C:静态方法
编译看左边，运行看左边
(5)多态的思想
指挥同一批对象做事情。举例：带兵打仗，下课等。

### 模板设计模式：
在定义功能时，功能的一部分是确定的，有一部分是不确定的，而且确定的部分在使用不确定的部分，
可将不确定的部分暴露出去，由该类的子类去完成。
如：求一段程序的运行时间例子。

### 异常
(1)程序运行过程中的不正常现象就叫异常。
(2)导致程序运行不正常的现象有很多，所以，就有很多的异常对象。
  而这些异常对象存在着共性的内容，所以，可以不断的进行抽取。最终形成了异常的体系结构。
  异常体系的根类是:Throwable
  Throwable：
|--Error:重大的问题，我们处理不了。也不需要编写代码处理。比如说内存溢出。
|--Exception:一般性的错误，是需要我们编写代码进行处理的。
|--RuntimeException:运行时异常，这个我们也不需要处理。
                   其实就是为了让他在运行时出问题，然后我们回来修改代码。
(3)异常的分类


异常有两种：
编译时被检测异常：
该异常在编译时，如果没有处理(没有抛也没有try)，编译失败。
该异常被标识，代表这可以被处理。
运行时异常(编译时不检测)
在编译时，不需要处理，编译器不检查。
该异常的发生，建议不处理，让程序停止。需要对代码进行修正。


(4)异常体系的特点：
异常体系中的所有类及其子类对象都具备可抛性。也就是说可以被throw和throws关键字所操作。


(5)main方法是如何处理异常的。
A:在main里面编写代码进行处理
B:交给jvm自己进行处理。采用的是jvm的默认处理方式。
 其实就是相当于调用了异常对象的printStackTrace()方法。
(6)Throwable类的学习
getMessage():获取异常信息，返回字符串。
toString():获取异常类名和异常信息，返回字符串。
printStackTrace():获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。


(7)异常的处理·
A:try...catch...finally
基本格式：
try
{
可能出现异常的代码
}
catch(异常对象)
{
异常处理代码
}
finally
{
释放资源
}
变形格式：
try...catch
try...catch...catch...
try...catch...catch...finally


**多个异常同时被捕获的时候，记住一个原则：
先逮小的，再逮大的。
**finally:永远被执行，除非退出jvm。System.exit(0);
面试题2个。
***：final,finally,finalize区别。
  final是最终的意思。它可以用于修饰类，成员变量，成员方法。
  它修饰的类不能被继承，它修饰的变量时常量，它修饰的方法不能被重写。
  finally:是异常处理里面的关键字。
  它其中的代码永远被执行。特殊情况：在执行它之前jvm退出。System.exit(0);
  finalize:是Object类中的一个方法。
  它是于垃圾回收器调用的方式。
***：假如catch中有return语句， finally里中的代码会执行吗？
  是在return前，还是在return后呢？
  会，在return前执行finally里面的代码。


(8)Exception和RuntimeException的区别
A:Exception:一般性的错误，是需要我们编写代码进行处理的。
B:RuntimeException:运行时异常，这个我们也不需要处理。
          其实就是为了让他在运行时出问题，然后我们回来修改代码。
在用throws抛出一个的时候，如果这个异常是属于RuntimeException的体系的时候，
我们在调用的地方可以不用处理。(RuntimeException和RuntimeException的子类)
在用throws抛出一个的时候，如果这个异常是属于Exception的体系的时候，
我们在调用的地方必须进行处理或者继续抛出。


(9)自定义异常
定义类继承Exception或者RuntimeException
1,为了让该自定义类具备可抛性。
2，让该类具备操作异常的共性方法。
 class MyExcepiton extends Exception  {    MyExcepiton(){}    MyExcepiton(String message)    {    super(message);    }  }  class MyException extends RuntimeException  {    MyExcepiton(){}    MyExcepiton(String message)    {    super(message);    }  }


(10)throws和throw的区别
A：有throws的时候可以没有throw。
  有throw的时候，如果throw抛的异常是Exception体系，那么必须有throws在方法上声明。

B：throws用于方法的声明上，其后跟的是异常类名，后面可以跟多个异常类，之间用逗号隔开

  throw用于方法体中，其后跟的是一个异常对象名













































