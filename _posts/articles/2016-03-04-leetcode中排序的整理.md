---
layout: article
title: "leetcode中排序的整理"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: leetcode.jpg
  thumb:
date: 2016-03-04T22:50:29+08:00
---

{% include toc.html %}

将leetcode上的排序整理一下，方便能够有条理的复习。提起排序，我们脑海中会迅速出现各种排序算法：冒泡排序、快速排序、简单排序、堆排序、直接插入排序、希尔排序（递减增量排序）、直接选择排序、堆排序、归并排序，其中能够有O(n lgn)时间复杂度的算法为，快速排序，堆排序，归并排序，而三者的空间复杂度分别为O(1), O(N),O(N)，理论上讲为了满足题目的要求我们需要在这是哪个排序算法里面找出需要的最合适的排序算法。

# 归并排序

归并排序是采用分治思想的典型排序算法，其算法复杂度是O(nLogn)，空间复杂度O(n)。通常来说，分治的思想会想到使用递归来实现，诚然，使用递归来实现归并排序的程序非常清晰，也易于理解。但凡递归实现的程序都可以转化为非递归实现，因为递归调用实际上就是栈操作而已。

归并排序的原理：

将原序列划分为有序的两个序列，然后利用归并算法进行合并，合并之后即为有序序列。既然明确了算法，那么我们就可以开始实现了。

1、从中单间把list分成两个

2、递归的排序两个子list

3、合并两个子list


{% highlight java %}

package algorithm.sort;
 
class ListNode {
	int val;
	ListNode next;
 
	ListNode(int x) {
		val = x;
		next = null;
	}
}

public class SortLinkedList {
 
	// 归并排序
	public static ListNode mergeSortList(ListNode head) {
 
		if (head == null || head.next == null)
			return head;
 
		// 通过一个遍历计算出list的长度
		int count = 0;
		ListNode p = head;
		while (p != null) {
			count++;
			p = p.next;
		}
 
		// 按照中间点分成两个list
		int middle = count / 2;
 
		ListNode l = head, r = null;
		ListNode p2 = head;
		int countHalf = 0;
		while (p2 != null) {
			countHalf++;
			ListNode next = p2.next;
 
			if (countHalf == middle) {
				p2.next = null;
				r = next;
			}
			p2 = next;
		}
 
		// 得到了两个list l和r，进行递归排序
		ListNode h1 = mergeSortList(l);
		ListNode h2 = mergeSortList(r);
 
		// 将两个list合并到一起
		ListNode merged = merge(h1, h2);
 
		return merged;
	}
 
	public static ListNode merge(ListNode l, ListNode r) {
		ListNode p1 = l;
		ListNode p2 = r;
 
		//需要的额外空间开销
		ListNode fakeHead = new ListNode(100);
		//把头结点给pNew
		ListNode pNew = fakeHead;
 
		while (p1 != null || p2 != null) {

 			//如果p1到头了,把p2的节点一个一个的接在pNew上这个假链上，和p2同时往后走
			if (p1 == null) {
				pNew.next = new ListNode(p2.val);
				p2 = p2.next;
				pNew = pNew.next;
			//如果p2到头了
			} else if (p2 == null) {
				pNew.next = new ListNode(p1.val);
				p1 = p1.next;
				pNew = pNew.next;
			} else {
				//进行值大小的比较，进行有序的拼接，存在三种情况，大于、等于和小于
				if (p1.val < p2.val) {
					// if(fakeHead)
					pNew.next = new ListNode(p1.val);
					p1 = p1.next;
					pNew = pNew.next;
				} else if (p1.val == p2.val) {
					pNew.next = new ListNode(p1.val);
					pNew.next.next = new ListNode(p1.val);
					pNew = pNew.next.next;
					p1 = p1.next;
					p2 = p2.next;
 
				} else {
					pNew.next = new ListNode(p2.val);
					p2 = p2.next;
					pNew = pNew.next;
				}
			}
		}
 
		// printList(fakeHead.next);
		return fakeHead.next;
	}
 
	public static void main(String[] args) {
		ListNode n1 = new ListNode(2);
		ListNode n2 = new ListNode(3);
		ListNode n3 = new ListNode(4);
 
		ListNode n4 = new ListNode(3);
		ListNode n5 = new ListNode(4);
		ListNode n6 = new ListNode(5);
 
		n1.next = n2;
		n2.next = n3;
		n3.next = n4;
		n4.next = n5;
		n5.next = n6;
 
		n1 = mergeSortList(n1);
 
		printList(n1);
	}
 
	public static void printList(ListNode x) {
		if(x != null){
			System.out.print(x.val + " ");
			while (x.next != null) {
				System.out.print(x.next.val + " ");
				x = x.next;
			}
			System.out.println();
		}
 
	}
}

{% endhighlight %}

# 快速排序

快速排序是一个分治算法，首先将一个大的list划分成两个小的子list，如果我们想排列一个数组并且不花费额外的空间，快速排序是一个很好的选择，平均情况下，时间复杂度为 O(n log(n))

排序的基本步骤

1、选择一个基准元素，通常情况下选择中当间的那个

2、在两个的尾部，进行交换元素操作，使得在基准元素左边的元素都要小于基准元素，基准元素右边元素都要大于基准元素

3、递归排序左边和右边的部分

[这里](http://www.programcreek.com/2012/11/quicksort-array-in-java/)有一个很好的解释

{% highlight java %}
public class QuickSort {
	public static void main(String[] args) {
		int[] x = { 9, 2, 4, 7, 3, 7, 10 };
		System.out.println(Arrays.toString(x));
 
		int low = 0;
		int high = x.length - 1;
 
		quickSort(x, low, high);
		System.out.println(Arrays.toString(x));
	}
 
	public static void quickSort(int[] arr, int low, int high) {
		if (arr == null || arr.length == 0)
			return;
 
		if (low >= high)
			return;
 
		// 选择基准点
		int middle = low + (high - low) / 2;
		int pivot = arr[middle];
 
		// 使得 left < pivot 和 right > pivot
		int i = low, j = high;
		while (i <= j) {
			//如果小的话就继续下一个
			while (arr[i] < pivot) {
				i++;
			}
 			//大的话也是继续下一个
			while (arr[j] > pivot) {
				j--;
			}
 
			//如果这两种情况都不是就交换
			if (i <= j) {
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
				i++;
				j--;
			}
		}
 
		// 递归调用两个子部分
		if (low < j)
			quickSort(arr, low, j);
 
		if (high > i)
			quickSort(arr, i, high);
	}
}
{% endhighlight %}

其他一些好的资料：

http://blog.csdn.net/hguisu/article/details/7776068

http://cwind.iteye.com/blog/2234587