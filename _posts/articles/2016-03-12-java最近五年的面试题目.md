---
layout: article
title: "java最近五年的面试题目"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: Translate.jpg
  thumb:
date: 2016-03-12T11:50:29+08:00
---

{% include toc.html %}

原打算这篇文章和上一篇文章一起学习的，但大致浏览了一下内容后觉得这篇文章的内容极好，还是单独拿出来有利于未来查阅。

[原文地址](http://javarevisited.blogspot.sg/2015/10/133-java-interview-questions-answers-from-last-5-years.html)

## 多线程、并发和线程基础

### 我们可以在java中使数组为volatile吗

在高级java开发面试中经常用来考察的问题，并且有一定的迷惑性。

### volatile可以是非原子的操作变为原子操作吗

这也是在volatile上我喜欢问的问题。volatile不是原子的，但是有一些情况下你可以使用volatile变量使得方法变成原子操作。

例如，在类中定义一个长变量（64byte），如果你知道这个长变量要被多个线程访问，最好要把它变为volatile的，因为在java中读取长变量并不是原子性的，而是要分为两步完成，如果一个线程更新一个长变量的值，很有可能线程只看到一半的值(前32bit)，但是读写一个长变量或者double（64bit）是原子性的。

### volatile修改在实际中是如何使用的

一个使用的场景是使得double类型和长类型的变量读写成为原子性读写。double和长类型是64-bit的而且他们要分成两部分进行读操作。首先是前32位，然后是后32位，这不是原子性的，但是olatile double and long 的度确实原子性的。

volatile变量的另一个用法是提供内存栅栏，就像它在 Disrupter framework框架中用的一样。基本上，java内存模型在写入一个volatile变量之后插入一个写栅栏，在读之前插入一个读栅栏。也就是说，如果你写入了一个volatile变量那么你就要保证访问变量的任何线程都可以看到你写的值，这样做可以保证你所做的修改可以被其他任何线程可见，因为内存栅栏把其他的写刷入到缓存中去了。（两个方面，一个是写之后插入和读之前插入，这样可以保证你写的可以被其他线程看见并且是最新的值，因为有一个刷入缓存的操作）