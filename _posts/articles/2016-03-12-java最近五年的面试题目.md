---
layout: article
title: "java最近五年的面试题目"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: Translate.jpg
  thumb:
date: 2016-03-12T11:50:29+08:00
---

{% include toc.html %}

原打算这篇文章和上一篇文章一起学习的，但大致浏览了一下内容后觉得这篇文章的内容极好，还是单独拿出来有利于未来查阅。

[原文地址](http://javarevisited.blogspot.sg/2015/10/133-java-interview-questions-answers-from-last-5-years.html)

## 多线程、并发和线程基础

### 我们可以在java中使数组为volatile吗

在高级java开发面试中经常用来考察的问题，并且有一定的迷惑性。

### volatile可以是非原子的操作变为原子操作吗

这也是在volatile上我喜欢问的问题。volatile不是原子的，但是有一些情况下你可以使用volatile变量使得方法变成原子操作。

例如，在类中定义一个长变量（64byte），如果你知道这个长变量要被多个线程访问，最好要把它变为volatile的，因为在java中读取长变量并不是原子性的，而是要分为两步完成，如果一个线程更新一个长变量的值，很有可能线程只看到一半的值(前32bit)，但是读写一个长变量或者double（64bit）是原子性的。

### volatile修改在实际中是如何使用的

一个使用的场景是使得double类型和长类型的变量读写成为原子性读写。double和长类型是64-bit的而且他们要分成两部分进行读操作。首先是前32位，然后是后32位，这不是原子性的，但是olatile double and long 的度确实原子性的。

volatile变量的另一个用法是提供内存栅栏，就像它在 Disrupter framework框架中用的一样。基本上，java内存模型在写入一个volatile变量之后插入一个写栅栏，在读之前插入一个读栅栏。也就是说，如果你写入了一个volatile变量那么你就要保证访问变量的任何线程都可以看到你写的值，这样做可以保证你所做的修改可以被其他任何线程可见，因为内存栅栏把其他的写刷入到缓存中去了。（两个方面，一个是写之后插入和读之前插入，这样可以保证你写的可以被其他线程看见并且是最新的值，因为有一个刷入缓存的操作）

除了以上两个方面的用法，还以用来替代synchronized关键字，因为volatile变量消耗更小。使用volatile关键关键字可以保证数据从主存中读取并且不是缓存在自己的栈中。

### volatile变量可以保证提供什么？

[一篇专门介绍volatile变量的文章](http://java67.blogspot.sg/2012/08/what-is-volatile-variable-in-java-when.html)

volatile变量提供有序和可见性的保证，例如，volatile任务不能被其他语句重排序，但是在同步指令编译器缺失的情况下，JVM或者JIT为了更好的性能可以进行重排序的工作。

volatile变量同样提供happens-before保证，确保每个线程的改变对于其他线程都是可见的。

在某一些情况下也可以提供原子保证，例如上边提到的六十四位的数据（原文中只是提到了读，没有提到写64位的数据）


### 哪种方式更容易写，为10个线程同步代码还是为2个线程同步代码

对于写代码而言，上边的两种都是很复杂的，因为同步代码是独立于线程完成的。根据一定数量的线程进行同步选择是因为大量的线程提供更多的内容，可以选择更好的同步技术比如lock等

### 你怎么调用wait方法，使用block还是loop循环，为什么

wait方法应该在loop循环中被调用，因为当线程获得CPU开始再次运行时条件或许并不满足，所以做好是放在loop循环中不断的做检查，下边是使用wait方法的标准用法（也就是说虽然在有些条件下你获得了CPU但是并不满足当前运行的条件，所以要放在loop循环中，达到条件才能运行）

{% highlight java %}
// The standard idiom for using the wait method synchronized (obj) { while (condition does not hold) obj.wait(); // (Releases lock, and reacquires on wakeup) ... // Perform action appropriate to condition }
{% endhighlight %}

[这个问题更好的文章](http://javarevisited.blogspot.sg/2015/07/how-to-use-wait-notify-and-notifyall-in.html)

下边是来自这篇文章的一些话

你可以使用 wait、notify和notifyall进行线程间的通信。例如生产者和消费者问题，一个线程可以使用wait（）方法来暂停一些工作，当队列满的时候生产者要调用wait进行等待……

### 什么是多线程的假分享（还是不明白）

假分享是多核系统中一个众所周知的性能问题，每一个处理都在本地的缓存中。当不同处理器上的线程修改变量时候假分享会发生

原文中有图

假分享很难被检测到，因为线程可以被完全不同的全局变量访问在这时候在内存中的数据相对靠近，像其他的并发问题一样，避免假分享的主要方式是小新编码并且要根据你的缓存的小排列你的数据结构。

### 什么是忙旋转（busy spin），你为什要使用它？

忙旋转是一种等待其他事件但不释放CPU的一种技术，这样做可以避免CPU缓存的数据丢失。所以，如果你在开发一个低延迟的系统，你当前处理的线程没有任何的顺序，替换sleeping和wait，你可以仅仅循环然后再次检查那个队列获取新的信息。在等待很短的时间的情况下这样做很有效，在纳秒或者微秒的级别是可以的。

### 你是怎么处理线程垃圾的

在linux中你可以使用 kill -3 PID来处理java应用程序中的线程垃圾，PID是java进程的ID

在windows的情况下，你可以使用 Ctrl + Break来处理，通过在控制台打印错误的消息，会知道JVM的线程垃圾。

### Swing是线程安全的吗？

### 在java中什么是线程本地变量

### 为生产者和消费者问题写wait-notify代码

### 用java写一个线程安全的单例

请一步一步的看例子中的代码，弄明白java是如何创建线程安全的单例的。当我们说线程安全的时候，意味着，即使在多线程的环境下也是单例的。在java中使用枚举是实现线程安全最简单的方式之一。

### java中的sleep和wait的区别

两个方法都是用来暂定当前执行的线程。sleep只是短暂的停止因为它并不释放锁，但是wait和条件等待是对等的，会释放锁，当其他的线程改变调价的时候会再一次获取这个锁。

### 什么是immutable对象，怎么创建immutable对象

immutable对象是一旦创建之后状态不能更改的，任何修改都会产生新的对象，例如：String、integer和其他的一些包装类，在原文中有很好的解释。new一个String就可以创建immutable对象

### 我们可以创建一个包含可变对象的不可变对象吗，

可以，创建一个包含可变对象的不可变对象是可以的，你只需要注意不要共享可变组件的引用，相反，你要返回它的一个拷贝。最常见的例子是对象包含ava.util.Date对象的引用。

## 数据类型和基本的java问题

### 在java中代表价格的正确数据类型是什么

如果不关系内存并且性能也不关键的时候可以选择BigDecimal，否则的话选择double 

### 怎么把一个bytes转为String

你可以通过使用String接受byte[]构造器来转化为String，需要注意的是编码的字符，有些平台默认编码或许不支持

### 怎么把一个byte转为long

### 我们能把int强制转换为byte变量，啊，如果int比byte值大会发生什么

可以，我们可以把int强制转化为byte，但是int是32位的，byte在java中是8位的，当你把一个int强制转化为byte的时候，高位的24位将会丢失

### B extends A 和C extends B,我们可以C=（C）B吗

### 哪个类包含clone方法？cloneable 或者Object

java.lang.Cloneable是一个标志性接口，里边没有任何方法，这个方法是定义在object中的。clone方法是原生方法意味着它是用C或者C++或者其他原生语言实现的。

### ++操作符是线程安全的吗

不是，不是线程安全的，因为它包含了多个指令，比如读取值、增加它的值并把它存回到内存中，这个过程可以导致多个线程进入并修改

### a=a+b和a+=b的区别?

### 我们可以在不使用强制转换的前提下把一个double变量存储在long变量中吗

不可以，因为double的范围要比long要更长，你需要强制转换。这个问题并不难回答，但是很多开发者都回答错了，因为大部分的人都把那个更长给弄混了。

### return 3*0.1==0.3会发生什么，真或假？

这是一个很具迷惑性的问题，100个开发者中只有5个开发者可以回答这个问题，答案是false，因为浮点数不能精确的代表数值。

### 哪个会消耗更多的内存int还是Integer？

Integer消耗更多的内存，因为Integer是对象，需要存储对象的元数据，int是原生数据类型，需要更小的空间

### 为什么String是immutable的？

这个我最喜欢的一个问题之一，String是immutable的是因为java的设计者认为String将会被大量的使用，把它变为immutable可以允许共享一些String对象已达到优化的目的，在下边的文章中可以看到更多的细节。对于经验少的开发人员这是一个很严重的问题，一定对它进行充分的思考。

### 我们可以在switch case中使用String吗

### 在java中什么是构造链

## JVM 内部和垃圾回收面试问题


## java集合框架面试问题

### List、Set、Map和Queue的区别

### poll和remove的区别

这两个方法都是讲数据从队列中取出，但面对空队列的时候poll返回空，remove抛出异常

### LinkedHashMap和PriorityQueue的区别

PriorityQueue保证最大和最小优先级的元素使用在队列的头上，但是LinkedHashMap维持了元素插入的顺序。

### ArrayList和LinkedList的区别

最明显的区别是ArrayList是有数组结构支持的，支持随机存储，LinkedList不支持随机存储。

### 排序一个集合的方式有哪几种？

你可以使用排序的集合：TreeSet或者TreeMap

或者使用集合工具类Collections中的sort方法

### 怎么打印一个数组

使用Arrays.toString()或者使用Arrays.deepToString()

### java中的LinkedList是单链表还是双链表

双链表实现

### TreeMap的实现时那种树

红黑树（要了解是怎么实现的）

### Hashtable和HashMap有什么区别

（a）HashTable 从JDK1遍已经加进去了，HashMap是后来加进去的

（b）Hashtable是同步的但是速度要慢，HashMap不是同步的并且速度要快

（C）不允许有空null key,但是HashMap允许有一个null key

### HashSet在java内部中是如何工作的？

HashSet的内部是用HashMap实现的。因为map需要key和value,为所有的key默认有一个key.和HashMap一样HashSet不允许有重复的值，允许有一个null key。我的意思是你可以在HashSet中存储一个空对象。

### 写代码移除ArrayList中的元素

### 我可以实现自己的容器类吗并在for-each循环中使用

是的，你可以写自己的容器类，如果你想获取java中的loop循环那么就需要实现Iterator接口，或者实现集合类就可以默认获取这个属性了。

### ArrayList和HashMap的默认大小是多大

对于java7来说ArrayList的默认大小是10，HashMap的默认大小是16，它必须是2的幂级

{% highlight java %}
// from ArrayList.java JDK 1.7 private static final int DEFAULT_CAPACITY = 10; //from HashMap.java JDK 7 static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

Read more: http://javarevisited.blogspot.com/2015/10/133-java-interview-questions-answers-from-last-5-years.html#ixzz42gSVJUgG
{% endhighlight %}

### 两个不相等的对象可以有相同的hashcode吗

可以，不相同对象可以有同样的hashcode，这就是冲突发生的原因。相同的对象一定会有相同的hashcode

### 我们可以在hashcode方法中使用随机数吗

原文中有很好的解答

### Comparable和Comparator的区别

### 当重写equal之后，为什么要重写hashcode



























































