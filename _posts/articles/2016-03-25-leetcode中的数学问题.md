---
layout: article
title: "leetcode中的数学问题"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: leetcode.jpg
  thumb:
date: 2016-03-30T12:50:29+08:00
---

{% include toc.html %}

主要是参照这个[文章](http://www.programcreek.com/2012/11/top-10-algorithms-for-coding-interview/)上进行整理

{% highlight java %}

{% endhighlight %}

## Reverse Integer（翻转数字）

Reverse digits of an integer.
Example1: x = 123, return 321
Example2: x = -123, return -321

### 方案一

{% highlight java %}
public int reverse(int x) {

	//判断是否为零以下
	boolean flag = false;
	if (x < 0) {
		x = 0 - x;
		flag = true;
	}
 
	int res = 0;
	int p = x;
 
	while (p > 0) {
		int mod = p % 10;
		p = p / 10;
		res = res * 10 + mod;
	}
 
	if (flag) {
		res = 0 - res;
	}
 
	return res;
}
{% endhighlight %}

### 方案二

一个更优的解，不用判断是否为零

{% highlight java %}
public int reverse(int x) {
    int rev = 0;
    while(x != 0){
        rev = rev*10 + x%10;
        x = x/10;
    }
 
    return rev;
}
{% endhighlight %}

## Palindrome Number（回文）

Determine whether an integer is a palindrome. Do this without extra space.

整体的思路是：先求出来回文串的总位数，然后分别对回文串进行求余和相除得到左右两边的数据进行比较

{% highlight java %}
public class Solution {
    public boolean isPalindrome(int x) {
        //负数不是回文数
		if (x < 0)
			return false;
 
		//一共是多少位数的数字，去掉一位
		int div = 1;
		while (x / div >= 10) {
			div *= 10;
		}
 
		while (x != 0) {

			//求出左右两边的值
			int left = x / div;
			int right = x % 10;
 
			if (left != right)
				return false;
 
			//两边分别是以去掉左右两端
			x = (x % div) / 10;
			div /= 100;
		}
 
		return true;
    }
}
{% endhighlight %}

## Pow(x, n)

Implement pow(x, n).问题的关键是如何处理奇偶数

### 原生方法

{% highlight java %}
public class Solution {
    public double pow(double x, int n) {
        if(x == 0) return 0;
        if(n == 0) return 1;
 
        double result=1;
        for(int i=1; i<=n; i++){
            result = result * x;
        }
 
        return result;
    }
}
{% endhighlight %}

### 递归版本

递归版本得有一个计算的公式，使劲复杂度为O(logn)。公式为： x^n = x^(n/2) * x^(n/2) * x^(n%2)，最后这个是为了判断奇数和偶数而判定的。下边同时处理了n和x小于零的情况。

{% highlight java %}
public static double pow(double x, int n) {
    if(n == 0) 
        return 1;
 
    if(n == 1) 
        return x;
 
    int half = n/2;
    int remainder = n%2; 
 
 
    if(n % 2 ==1 && x < 0 && n < 0)
        return - 1/(pow(-x, half) * pow(-x, half) * pow(-x, remainder));
    else if (n < 0)
        return 1/(pow(x, -half) * pow(x, -half) * pow(x, -remainder));
    else 
        return (pow(x, half) * pow(x, half) * pow(x, remainder));
}
{% endhighlight %}

### AC

The accepted solution is also recursive, but does division first. Time complexity is O(nlog(n)). The key part of solving this problem is the while loop.

{% highlight java %}
public double pow(double x, int n) {
	if (n == 0)
		return 1;
	if (n == 1)
		return x;
 
	int pn = n > 0 ? n : -n;// positive n
	int pn2 = pn;
 
	double px = x > 0 ? x : -x;// positive x
	double result = px;
 
	int k = 1;
	//处理偶数
	while (pn / 2 > 0) {
		result = result * result;
		pn = pn / 2;
		k = k * 2;
	}
 
	result = result * pow(px, pn2 - k);
 
	//处理剩余那个奇数
	if (x < 0 && n % 2 == 1)
		result = -result;
 
	//处理n<0的情况
	if (n < 0)
		result = 1 / result;
 
	return result;
}
{% endhighlight %}

### 最好的方案

{% highlight java %}
public double power(double x, int n) {
	if (n == 0)
		return 1;
 
	//传递的是半个的幂
	double v = power(x, n / 2);
 
	if (n % 2 == 0) {
		return v * v;
	} else {
		return v * v * x;
	}
}
 
public double pow(double x, int n) {
	if (n < 0) {
		return 1 / power(x, -n);
	} else {
		return power(x, n);
	}
}
{% endhighlight %}

##  Count Primes

Count the number of prime numbers less than a non-negative number, n

### 方案一

这个方案超时

{% highlight java %}
public int countPrimes(int n) {
    n = n-1;
 
    ArrayList<Integer> primes = new ArrayList<Integer>();
 
    if(n<=1) 
        return 0;
    if(n==2)
        return 1;
    if(n==3)
        return 2;
 
    primes.add(2);
    primes.add(3);
 
    for(int i=4; i<=n; i++){
        boolean isPrime = true;
        for(int p: primes){
            int m = i%p;
            if(m==0){
                isPrime = false;
                break;
            }
        }
 
        if(isPrime){
            primes.add(i);
        }
    }
 
    return primes.size();
}
{% endhighlight %}

### 方案二

{% highlight java %}
public int countPrimes(int n) {
	if (n <= 2)
		return 0;
 
	// init an array to track prime numbers
	boolean[] primes = new boolean[n];
	for (int i = 2; i < n; i++)
		primes[i] = true;
 
	for (int i = 2; i <= Math.sqrt(n - 1); i++) {
	// or for (int i = 2; i <= n-1; i++) {
		if (primes[i]) {
			for (int j = i + i; j < n; j += i)
				primes[j] = false;
		}
	}
 
	int count = 0;
	for (int i = 2; i < n; i++) {
		if (primes[i])
			count++;
	}
 
	return count;
}
{% endhighlight %}

## subsets

[原文中有更多的解法](http://www.tuicool.com/articles/J3En2e)

Given a set of distinct integers, S, return all possible subsets.

{% highlight java %}
If  S  =  [1,2,3] , a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
{% endhighlight %}

只要我们能找到比原问题规模小却同质的问题，都可以用递归解决。比如要求{1, 2, 3}的所有子集，可以先求{2, 3}的所有子集，{2, 3}的子集同时也是{1, 2, 3} 的子集，然后我们把{2, 3}的所有子集都加上元素1后（注意排序），又得到同样数量的子集， 它们也是{1, 2, 3}的子集。这样一来，我们就可以通过求{2, 3}的所有子集来求 {1, 2, 3}的所有子集了。即为求1,2,3的子集，要先求2,3的子集，然后再把1加入到2,3的子集中去，典型的递归思路。代码如下： 

{% highlight java %}
/**
*总体流程，先取出原有集合的数据，在原有集合数据中添加新的元素
*再取出一个元素
*
**/
public ArrayList<ArrayList<Integer>> subsets(int[] S) {
	if (S == null)
		return null;

	//排不排序没有关系
	Arrays.sort(S);
 
	//结果集
	ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
 
	for (int i = 0; i < S.length; i++) {

		//一个临时的temp
		ArrayList<ArrayList<Integer>> temp = new ArrayList<ArrayList<Integer>>();
 
		//获取已经在结果集中的集合
		for (ArrayList<Integer> a : result) {
			temp.add(new ArrayList<Integer>(a));
		}
 
		//将新添加的那个元素，增加到原有的集合后边，形成新的串
		//由于是对象的引用，所以添加完之后temp的值也相应的跟着改变
		for (ArrayList<Integer> a : temp) {
			a.add(S[i]);
		}
 
		//每次处理完成之后加载一个新的元素
		ArrayList<Integer> single = new ArrayList<Integer>();
		single.add(S[i]);
		temp.add(single);
 
		//将新的结果集添加到里边去
		//addAll是将对等的list增加进去
		result.addAll(temp);
	}
 
	//最后再增加一个空的串
	result.add(new ArrayList<Integer>());
 
	return result;
}
{% endhighlight %}