---
layout: article
title: "leetcode字符串和数组"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: leetcode.jpg
  thumb:
date: 2016-03-10T22:50:29+08:00
---

{% include toc.html %}

# 旋转数组

You may have been using Java for a while. Do you think a simple Java array question can be a challenge? Let's use the following problem to test.

Problem: Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. How many different ways do you know to solve this problem?

## 中间数组

最简单的方式，我们创建一个新的数组，把元素复制到新的数据中去。利用System.arraycopy()实现数组的复制
{% highlight java %}

public void rotate(int[] nums, int k) {

    //K是一个可能大于长度的数据，因此要进行求余处理
    if(k > nums.length) 
        k=k%nums.length;
 
	//申请同级别大小的数据
    int[] result = new int[nums.length];
 
	//k之前的数据，根据数学计算得到两个数组间的映射关系
    for(int i=0; i < k; i++){
        result[i] = nums[nums.length-k+i];
    }
 
	//k之后的数据
    int j=0;
    for(int i=k; i<nums.length; i++){
        result[i] = nums[j];
        j++;
    }
 
    System.arraycopy( result, 0, nums, 0, nums.length );
}
{% endhighlight %}

空间复杂度和时间复杂度都是 O(n) 

## 冒泡旋转

空间复杂度是 O(n) ，但是时间复杂度却是O(n*k)

{% highlight java %}

public static void rotate(int[] arr, int order) {
	if (arr == null || order < 0) {
	    throw new IllegalArgumentException("Illegal argument!");
	}
 
	for (int i = 0; i < order; i++) {
	
		//每次都向后移动一次，一共移动order次
		for (int j = arr.length - 1; j > 0; j--) {
			int temp = arr[j];
			arr[j] = arr[j - 1];
			arr[j - 1] = temp;
		}
	}
}

{% endhighlight %}

## 翻转

O(1) 空间复杂度 和 O(n)时间复杂度 

1 Divide the array two parts: 1,2,3,4 and 5, 6

2.Rotate first part: 4,3,2,1,5,6

3.Rotate second part: 4,3,2,1,6,5

4.Rotate the whole array: 5,6,1,2,3,4

{% highlight java %}

public static void rotate(int[] arr, int order) {
	order = order % arr.length;
 
	if (arr == null || order < 0) {
		throw new IllegalArgumentException("Illegal argument!");
	}
 
	//length of first part
	int a = arr.length - order; 
 
	reverse(arr, 0, a-1);
	reverse(arr, a, arr.length-1);
	reverse(arr, 0, arr.length-1);
 
}
 
public static void reverse(int[] arr, int left, int right){
	if(arr == null || arr.length == 1) 
		return;
 
	while(left < right){
		int temp = arr[left];
		arr[left] = arr[right];
		arr[right] = temp;
		left++;
		right--;
	}	
}

{% endhighlight %}

# Evaluate Reverse Polish Notation(逆波兰表达式)

表达式:： ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9   ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
题目大意：给定一个逆波兰表达式，求该表达式的值

思路：由于逆波兰表达式本身不需要括号来限制哪个运算该先进行，因此可以直接利用栈来模拟计算：遇到操作数直接压栈，碰到操作符直接取栈顶的2个操作数进行计算（注意第一次取出来的是右操作数），然后再把计算结果压栈，如此循环下去。最后栈中剩下的唯一一个元素便是整个表达式的值。

{% highlight java %}
public class Test {
 
	public static void main(String[] args) throws IOException {
		String[] tokens = new String[] { "2", "1", "+", "3", "*" };
		System.out.println(evalRPN(tokens));
	}
 
	public static int evalRPN(String[] tokens) {
		int returnValue = 0;
		String operators = "+-*/";
 
		Stack<String> stack = new Stack<String>();
 
		for (String t : tokens) {

			 //将数字压入栈
			if (!operators.contains(t)) {
				stack.push(t);
 
			//遇到操作符，取出两个数字计算，并再次压入栈
			} else {//pop numbers from stack if it is an operator
				int a = Integer.valueOf(stack.pop());
				int b = Integer.valueOf(stack.pop());
				switch (t) {
				case "+":
					stack.push(String.valueOf(a + b));
					break;
				case "-":
					stack.push(String.valueOf(b - a));
					break;
				case "*":
					stack.push(String.valueOf(a * b));
					break;
				case "/":
					stack.push(String.valueOf(b / a));
					break;
				}
			}
		}
 
		//所有的都结束，弹出即可
		returnValue = Integer.valueOf(stack.pop());
 
		return returnValue;
	}
}

{% endhighlight %}

# Isomorphic Strings (同构串)

For example,"egg" and "add" are isomorphic, "foo" and "bar" are not.
paper and title also are isomorphic

遍历S的每一个字母，并且记录s[i]到t[i]的映射，当发现与已有的映射不同时，就说明无法同构。但是这样只能保证s到t的映射，反过来则不可以，s与t交换位置重来一遍就可以了。

{% highlight java %}
import java.util.HashMap;
 
/**
 * 功能说明：LeetCode 205 - Isomorphic Strings
 * 开发人员：Tsybius2014
 * 开发时间：2015年8月8日
 */
public class Solution {
     
    /**
     * 判断字符串是否同构
     * @param s 字符串s
     * @param t 字符串t
     * @return
     */
    public boolean isIsomorphic(String s, String t) {
         
        if (s.length() != t.length()) {
            return false;
        }
 
        HashMap<Character, Character> hashMapS = new HashMap<Character, Character>();
        HashMap<Character, Character> hashMapT = new HashMap<Character, Character>();
         
        for (int i = 0; i < s.length(); i++) {
            if (hashMapS.containsKey(s.charAt(i))) {
				//如果有重复的，把把根据key值存进去的数取出来跟t上相应的位置对比，相同的话则为真
                if (hashMapS.get(s.charAt(i)) != t.charAt(i)) {
                    return false;
                }
            } else {
                if (hashMapT.containsKey(t.charAt(i))) {
                    return false;
                }
                hashMapS.put(s.charAt(i), t.charAt(i));
                hashMapT.put(t.charAt(i), s.charAt(i));
            }
        }
         
        return true;
    }
}

{% endhighlight %}