---
layout: article
title: "leetcode字符串和数组"
modified:
categories: articles
excerpt: ""
comments: true
tags: []
image: 
  feature: 1600x800.gif.jpg
  teaser: leetcode.jpg
  thumb:
date: 2016-03-12T09:50:29+08:00
---

{% include toc.html %}

# 旋转数组

You may have been using Java for a while. Do you think a simple Java array question can be a challenge? Let's use the following problem to test.

Problem: Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. How many different ways do you know to solve this problem?

## 中间数组

最简单的方式，我们创建一个新的数组，把元素复制到新的数据中去。利用System.arraycopy()实现数组的复制
{% highlight java %}

public void rotate(int[] nums, int k) {

    //K是一个可能大于长度的数据，因此要进行求余处理
    if(k > nums.length) 
        k=k%nums.length;
 
	//申请同级别大小的数据
    int[] result = new int[nums.length];
 
	//k之前的数据，根据数学计算得到两个数组间的映射关系
    for(int i=0; i < k; i++){
        result[i] = nums[nums.length-k+i];
    }
 
	//k之后的数据
    int j=0;
    for(int i=k; i<nums.length; i++){
        result[i] = nums[j];
        j++;
    }
 
    System.arraycopy( result, 0, nums, 0, nums.length );
}
{% endhighlight %}

空间复杂度和时间复杂度都是 O(n) 

## 冒泡旋转

空间复杂度是 O(n) ，但是时间复杂度却是O(n*k)

{% highlight java %}

public static void rotate(int[] arr, int order) {
	if (arr == null || order < 0) {
	    throw new IllegalArgumentException("Illegal argument!");
	}
 
	for (int i = 0; i < order; i++) {
	
		//每次都向后移动一次，一共移动order次
		for (int j = arr.length - 1; j > 0; j--) {
			int temp = arr[j];
			arr[j] = arr[j - 1];
			arr[j - 1] = temp;
		}
	}
}

{% endhighlight %}

## 翻转

O(1) 空间复杂度 和 O(n)时间复杂度 

1 Divide the array two parts: 1,2,3,4 and 5, 6

2.Rotate first part: 4,3,2,1,5,6

3.Rotate second part: 4,3,2,1,6,5

4.Rotate the whole array: 5,6,1,2,3,4

{% highlight java %}

public static void rotate(int[] arr, int order) {
	order = order % arr.length;
 
	if (arr == null || order < 0) {
		throw new IllegalArgumentException("Illegal argument!");
	}
 
	//length of first part
	int a = arr.length - order; 
 
	reverse(arr, 0, a-1);
	reverse(arr, a, arr.length-1);
	reverse(arr, 0, arr.length-1);
 
}
 
public static void reverse(int[] arr, int left, int right){
	if(arr == null || arr.length == 1) 
		return;
 
	while(left < right){
		int temp = arr[left];
		arr[left] = arr[right];
		arr[right] = temp;
		left++;
		right--;
	}	
}

{% endhighlight %}

# Evaluate Reverse Polish Notation(逆波兰表达式)

表达式:： ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9   ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
题目大意：给定一个逆波兰表达式，求该表达式的值

思路：由于逆波兰表达式本身不需要括号来限制哪个运算该先进行，因此可以直接利用栈来模拟计算：遇到操作数直接压栈，碰到操作符直接取栈顶的2个操作数进行计算（注意第一次取出来的是右操作数），然后再把计算结果压栈，如此循环下去。最后栈中剩下的唯一一个元素便是整个表达式的值。

{% highlight java %}
public class Test {
 
	public static void main(String[] args) throws IOException {
		String[] tokens = new String[] { "2", "1", "+", "3", "*" };
		System.out.println(evalRPN(tokens));
	}
 
	public static int evalRPN(String[] tokens) {
		int returnValue = 0;
		String operators = "+-*/";
 
		Stack<String> stack = new Stack<String>();
 
		for (String t : tokens) {

			 //将数字压入栈
			if (!operators.contains(t)) {
				stack.push(t);
 
			//遇到操作符，取出两个数字计算，并再次压入栈
			} else {//pop numbers from stack if it is an operator
				int a = Integer.valueOf(stack.pop());
				int b = Integer.valueOf(stack.pop());
				switch (t) {
				case "+":
					stack.push(String.valueOf(a + b));
					break;
				case "-":
					stack.push(String.valueOf(b - a));
					break;
				case "*":
					stack.push(String.valueOf(a * b));
					break;
				case "/":
					stack.push(String.valueOf(b / a));
					break;
				}
			}
		}
 
		//所有的都结束，弹出即可
		returnValue = Integer.valueOf(stack.pop());
 
		return returnValue;
	}
}

{% endhighlight %}

# Isomorphic Strings (同构串)

For example,"egg" and "add" are isomorphic, "foo" and "bar" are not.
paper and title also are isomorphic

遍历S的每一个字母，并且记录s[i]到t[i]的映射，当发现与已有的映射不同时，就说明无法同构。但是这样只能保证s到t的映射，反过来则不可以，s与t交换位置重来一遍就可以了。

{% highlight java %}
import java.util.HashMap;
 
/**
 * 功能说明：LeetCode 205 - Isomorphic Strings
 * 开发人员：Tsybius2014
 * 开发时间：2015年8月8日
 */
public class Solution {
     
    /**
     * 判断字符串是否同构
     * @param s 字符串s
     * @param t 字符串t
     * @return
     */
    public boolean isIsomorphic(String s, String t) {
         
        if (s.length() != t.length()) {
            return false;
        }
 
        HashMap<Character, Character> hashMapS = new HashMap<Character, Character>();
        HashMap<Character, Character> hashMapT = new HashMap<Character, Character>();
         
        for (int i = 0; i < s.length(); i++) {
            if (hashMapS.containsKey(s.charAt(i))) {
				//如果有重复的，把把根据key值存进去的数取出来跟t上相应的位置对比，相同的话则为真
                if (hashMapS.get(s.charAt(i)) != t.charAt(i)) {
                    return false;
                }
            } else {
                if (hashMapT.containsKey(t.charAt(i))) {
                    return false;
                }
                hashMapS.put(s.charAt(i), t.charAt(i));
                hashMapT.put(t.charAt(i), s.charAt(i));
            }
        }
         
        return true;
    }
}

{% endhighlight %}


# word ladder

Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that only one letter can be changed at a time and each intermediate word must exist in the dictionary. For example, given:

start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
One shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", the program should return its length 5.

给定一个字典，一个起始单词start，一个终止单词end。使用字典内的单词作为中间状态，每次变换start的一个字母直到原起始单词变为终止单词end。注：单词长度一致。问：（1）最少多少步能完成操作？（2）输出长度，

乍看起来很难的一题，其实仔细分析就是图的遍历。把start,end和dict里的词都看作一个个结点，如果一个词可以合法转化为另一个词，那么视为这两个“结点”中间有一条路径。问题则变为，找到从start到end的最短路径长度。

如果采用扫描所有dict中单词，然后判断是否合法来遍历结点的方法，会超时（因为有dict中单词过多的用例）。所以只能采用别的遍历思路。

一个有效的遍历思路是获取到当前单词长度，然后对每一位都尝试替换为别的字符来遍历，即得到所以可能的合法字符串，然后判断是否等于end，或者在dict中且不在已遍历过的结点中，这样时间复杂度就是O(l)仅仅跟单词长度有关了。

对每一个结点，都用HashMap保存start到它的路径长度，新结点进入时只需要把长度加一即可。

采用广度优先遍历比较好，因为我们只需要获得最短的路径长度，而广度优先可以保证第一个到达end的路径是最短的（即到达end即可以return）。


{% highlight java %}
public int ladderLength(String start, String end, Set<String> dict) {
        HashMap<String, Integer> hm = new HashMap<String, Integer>();
        Queue<String> q = new LinkedList<String>();
		
		//先加入开始，因为肯定是从start开始到end结束
        q.add(start);

		//开始首先要把长度加进去
        hm.put(start,1);
        
        while(!q.isEmpty())
        {
            String temp = q.poll(); 
            int len = hm.get(temp);
            for(int i=0;i<temp.length();i++) {
                for(char c='a';c<='z';c++) {
 
					//将完全重复的过滤掉，把不同的留下来判断
                    if(c==temp.charAt(i))
                        continue;
                    StringBuilder sb = new StringBuilder(temp);

					//setCharAt，在某个位置替换为相应的字母，利用StringBuilder的属性
                    sb.setCharAt(i,c);
                    String next = sb.toString();
                    
                    if(next.equals(end))
                        return len+1;

					//首先要确定字典中包含，其次不在已经遍历的节点中
                    if(dict.contains(next) && !hm.containsKey(next)) {
                        q.add(next);
                        hm.put(next,len+1);
                    }
                }
            }
        }
        return 0;
    }
{% endhighlight %}

# word ladder II

Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:

Only one letter can be changed at a time
Each intermediate word must exist in the dictionary
For example,

Given:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]

Return

  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]

难度挺高的一题。沿用Word Ladder I的思路，此题本质也是图的遍历问题，求的是从给定起点到给定终点之间的所有最短路径。

Word Ladder I 中，找到一条合法路径即返回。然而此题中找到一条之后还需要进行讨论，问题就变复杂了，因为广度优先遍历中之前的节点都已经出队列没法再获取到。

所以，沿用Word Ladder I中的思想，不仅记录每个结点距离start的距离，而且用List记录这个到达这个节点的所有最短路径上的前驱结点。举个例子：


[原文地址](http://www.cnblogs.com/splash/p/4102786.html)


6的List应当为 2 和 3， 因为5 不是最短路径上的点。

这里采用HashMap去处理结点和List的映射关系。

这样在进行广度优先遍历过程中，会有以下几种情况：

1. 相邻结点新结点，那么新结点入队列；建立新结点的List和，把当前结点加入到新结点的List中；记录新结点的最短路径长度为当前结点的最短路径长度L+1

2. 相邻结点在队列中（例如上图结点3出队列时，6还在队列中）且相邻结点的最短路径长度=当前结点最短路径长度+1，那么说明是另一条最短路径，只需要把当前结点加入到相邻结点的List中。

3. 相邻结点在队列中且相邻结点的最短路径长度<当前结点最短路径长度+1,说明这条不是最短路径，那么什么也不做，当前结点默默出队列。

这样我们可以得到从start到end的若干条链，从end开始逆向使用回溯法记录所有的链上的结点即可。


{% highlight java %}

HashMap<String, ArrayList<String>> nodeSet = new HashMap<String, ArrayList<String>>();
    public List<List<String>> findLadders(String start, String end, Set<String> dict) {
        List<List<String>> re = new ArrayList<List<String>>();
        Queue<String> q = new LinkedList<String>();
        HashSet<String> hs = new HashSet<String>();
        HashMap<String, Integer> dist = new HashMap<String, Integer>();
        q.add(start);
        nodeSet.put(start, new ArrayList<String>());
        nodeSet.put(end, new ArrayList<String>());
        dist.put(start, 1);
        
        while(!q.isEmpty()) {
            String temp = q.poll();
            int l = dist.get(temp);
            hs.add(temp);
            for(int i=0;i<temp.length();i++) {
                for(char c='a';c<='z';c++) {
                    if(temp.charAt(i)==c)
                        continue;
                    StringBuilder sb = new StringBuilder(temp);
                    sb.setCharAt(i,c);
                    String next = sb.toString();
                    if(next.equals(end)) {
                        if(!dist.containsKey(end)) {
                            dist.put(end,l+1);
                            nodeSet.get(end).add(temp);
                        }
                        else if(dist.get(end)==l+1)
                            nodeSet.get(end).add(temp);
                    }
                    else if(dict.contains(next) && !hs.contains(next)) {
                        if(!dist.containsKey(next)) {
                            q.add(next);
                            dist.put(next, l+1);
                            ArrayList<String> arr = new ArrayList<String>();
                            arr.add(temp);
                            nodeSet.put(next, arr);
                        } else if(dist.get(next)==l+1)
                            nodeSet.get(next).add(temp);
                    }
                }
            }
        }
        List<String> path = new ArrayList<String>();
        path.add(end);
        collect(start,re,path,nodeSet.get(end));
        return re;
    }
    public void collect(String start, List<List<String>> re, List<String> path, ArrayList<String> prevNodes)
    {
        for(int i=0;i<prevNodes.size();i++)
        {
            path.add(0,prevNodes.get(i));
            if(prevNodes.get(i).equals(start)) {
                List<String> pathCopy = new ArrayList<String>(path);
                re.add(pathCopy);
            }
            else
                collect(start,re,path,nodeSet.get(prevNodes.get(i)));
            path.remove(0);
        }
    }
{% endhighlight %}